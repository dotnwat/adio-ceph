<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>VampirTrace - User Manual</TITLE>
<META NAME="description" CONTENT="VampirTrace - User Manual">
<META NAME="keywords" CONTENT="UserManual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<STYLE>
/* Century Schoolbook font is very similar to Computer Modern Math: cmmi */
.MATH    { font-family: "Century Schoolbook", serif; }
.MATH I  { font-family: "Century Schoolbook", serif; font-style: italic }
.BOLDMATH { font-family: "Century Schoolbook", serif; font-weight: bold }

/* implement both fixed-size and relative sizes */
SMALL.XTINY		{ font-size : xx-small }
SMALL.TINY		{ font-size : x-small  }
SMALL.SCRIPTSIZE	{ font-size : smaller  }
SMALL.FOOTNOTESIZE	{ font-size : small    }
SMALL.SMALL		{  }
BIG.LARGE		{  }
BIG.XLARGE		{ font-size : large    }
BIG.XXLARGE		{ font-size : x-large  }
BIG.HUGE		{ font-size : larger   }
BIG.XHUGE		{ font-size : xx-large }

/* heading styles */
H1		{  }
H2		{  }
H3		{  }
H4		{  }
H5		{  }

/* mathematics styles */
DIV.displaymath		{ }	/* math displays */
TD.eqno			{ }	/* equation-number cells */


/* document-specific styles come next */
PRE.preform		{   }
DIV.footnotesize		{   }
DIV.small		{   }
DIV.center		{   }
DIV.navigation		{   }
SPAN.textbf		{ font-weight: bold  }
SPAN.arabic		{   }
SPAN.textit		{ font-style: italic  }

BODY			{ font-family: sans-serif; }
</STYLE>

</HEAD>

<BODY >

<P>

<P>
<B><BIG CLASS="XHUGE">VampirTrace 5.11&nbsp;User Manual</BIG></B>
<BR>
<BR>
<BR>
TU Dresden
<BR>
Center for Information Services and 
<BR>
High Performance Computing (ZIH)
<BR>
01062 Dresden
<BR>
Germany
<BR>
<BR><TT><A NAME="tex2html1"
  HREF="http://www.tu-dresden.de/zih">http://www.tu-dresden.de/zih</A></TT>
<BR><TT><A NAME="tex2html2"
  HREF="http://www.tu-dresden.de/zih/vampirtrace">http://www.tu-dresden.de/zih/vampirtrace</A></TT>
<BR>
<BR>
Contact: mailto:vampirsupport@zih.tu-dresden.devampirsupport@zih.tu-dresden.de

<P>
<BR>

<H2><A NAME="SECTION00100000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><A NAME="tex2html82"
  HREF="UserManual.html#SECTION00200000000000000000">Introduction</A>
<LI><A NAME="tex2html83"
  HREF="UserManual.html#SECTION00300000000000000000">Instrumentation</A>
<UL>
<LI><A NAME="tex2html84"
  HREF="UserManual.html#SECTION00310000000000000000">Compiler Wrappers</A>
<LI><A NAME="tex2html85"
  HREF="UserManual.html#SECTION00320000000000000000">Instrumentation Types</A>
<LI><A NAME="tex2html86"
  HREF="UserManual.html#SECTION00330000000000000000">Automatic Instrumentation</A>
<UL>
<LI><A NAME="tex2html87"
  HREF="UserManual.html#SECTION00331000000000000000">Supported Compilers</A>
<LI><A NAME="tex2html88"
  HREF="UserManual.html#SECTION00332000000000000000">Notes for Using the GNU, Intel, or PathScale Compiler</A>
<LI><A NAME="tex2html89"
  HREF="UserManual.html#SECTION00333000000000000000">Notes on Instrumentation of Inline Functions</A>
<LI><A NAME="tex2html90"
  HREF="UserManual.html#SECTION00334000000000000000">Instrumentation of Loops with OpenUH Compiler</A>
</UL>
<LI><A NAME="tex2html91"
  HREF="UserManual.html#SECTION00340000000000000000">Manual Instrumentation</A>
<UL>
<LI><A NAME="tex2html92"
  HREF="UserManual.html#SECTION00341000000000000000">Using the VampirTrace API</A>
<LI><A NAME="tex2html93"
  HREF="UserManual.html#SECTION00342000000000000000">Measurement Controls</A>
</UL>
<LI><A NAME="tex2html94"
  HREF="UserManual.html#SECTION00350000000000000000">Source Instrumentation Using PDT/TAU</A>
<LI><A NAME="tex2html95"
  HREF="UserManual.html#SECTION00360000000000000000">Binary Instrumentation Using Dyninst</A>
<UL>
<LI><A NAME="tex2html96"
  HREF="UserManual.html#SECTION00361000000000000000">Static Binary Instrumentation</A>
</UL>
<LI><A NAME="tex2html97"
  HREF="UserManual.html#SECTION00370000000000000000">Runtime Instrumentation Using VTRun</A>
<LI><A NAME="tex2html98"
  HREF="UserManual.html#SECTION00380000000000000000">Tracing Java Applications Using JVMTI</A>
<LI><A NAME="tex2html99"
  HREF="UserManual.html#SECTION00390000000000000000">Tracing Calls to 3rd-Party Libraries</A>
</UL>
<BR>
<LI><A NAME="tex2html100"
  HREF="UserManual.html#SECTION00400000000000000000">Runtime Measurement</A>
<UL>
<LI><A NAME="tex2html101"
  HREF="UserManual.html#SECTION00410000000000000000">Trace File Name and Location</A>
<LI><A NAME="tex2html102"
  HREF="UserManual.html#SECTION00420000000000000000">Environment Variables</A>
<LI><A NAME="tex2html103"
  HREF="UserManual.html#SECTION00430000000000000000">Influencing Trace Buffer Size</A>
<LI><A NAME="tex2html104"
  HREF="UserManual.html#SECTION00440000000000000000">Profiling an Application</A>
<LI><A NAME="tex2html105"
  HREF="UserManual.html#SECTION00450000000000000000">Unification of Local Traces</A>
<LI><A NAME="tex2html106"
  HREF="UserManual.html#SECTION00460000000000000000">Synchronized Buffer Flush</A>
<LI><A NAME="tex2html107"
  HREF="UserManual.html#SECTION00470000000000000000">Enhanced Timer Synchronization</A>
<LI><A NAME="tex2html108"
  HREF="UserManual.html#SECTION00480000000000000000">Environment Configuration Using VTSetup</A>
</UL>
<BR>
<LI><A NAME="tex2html109"
  HREF="UserManual.html#SECTION00500000000000000000">Recording Additional Events and Counters</A>
<UL>
<LI><A NAME="tex2html110"
  HREF="UserManual.html#SECTION00510000000000000000">Hardware Performance Counters</A>
<LI><A NAME="tex2html111"
  HREF="UserManual.html#SECTION00520000000000000000">Resource Usage Counters</A>
<LI><A NAME="tex2html112"
  HREF="UserManual.html#SECTION00530000000000000000">Memory Allocation Counter</A>
<LI><A NAME="tex2html113"
  HREF="UserManual.html#SECTION00540000000000000000">CPU ID Counter</A>
<LI><A NAME="tex2html114"
  HREF="UserManual.html#SECTION00550000000000000000">NVIDIA CUDA Runtime API and Kernels</A>
<LI><A NAME="tex2html115"
  HREF="UserManual.html#SECTION00560000000000000000">Pthread API Calls</A>
<LI><A NAME="tex2html116"
  HREF="UserManual.html#SECTION00570000000000000000">Plugin Counter Metrics</A>
<LI><A NAME="tex2html117"
  HREF="UserManual.html#SECTION00580000000000000000">I/O Calls</A>
<LI><A NAME="tex2html118"
  HREF="UserManual.html#SECTION00590000000000000000">fork/system/exec Calls</A>
<LI><A NAME="tex2html119"
  HREF="UserManual.html#SECTION005100000000000000000">MPI Correctness Checking Using UniMCI</A>
<LI><A NAME="tex2html120"
  HREF="UserManual.html#SECTION005110000000000000000">User-defined Counters</A>
<LI><A NAME="tex2html121"
  HREF="UserManual.html#SECTION005120000000000000000">User-defined Markers</A>
<LI><A NAME="tex2html122"
  HREF="UserManual.html#SECTION005130000000000000000">User-defined Communcation</A>
</UL>
<BR>
<LI><A NAME="tex2html123"
  HREF="UserManual.html#SECTION00600000000000000000">Filtering &amp; Grouping</A>
<UL>
<LI><A NAME="tex2html124"
  HREF="UserManual.html#SECTION00610000000000000000">Function Filtering</A>
<LI><A NAME="tex2html125"
  HREF="UserManual.html#SECTION00620000000000000000">Java Specific Filtering</A>
<LI><A NAME="tex2html126"
  HREF="UserManual.html#SECTION00630000000000000000">Function Grouping</A>
</UL>
<BR>
<LI><A NAME="tex2html127"
  HREF="UserManual.html#SECTION00700000000000000000">Counter Specifications</A>
<UL>
<LI><A NAME="tex2html128"
  HREF="UserManual.html#SECTION00710000000000000000">PAPI</A>
<LI><A NAME="tex2html129"
  HREF="UserManual.html#SECTION00720000000000000000">CPC</A>
<LI><A NAME="tex2html130"
  HREF="UserManual.html#SECTION00730000000000000000">NEC SX Hardware Performance Counter</A>
<LI><A NAME="tex2html131"
  HREF="UserManual.html#SECTION00740000000000000000">Resource Usage</A>
</UL></UL>
<!--End of Table of Contents-->
<P>
This documentation describes how to apply VampirTrace to an application 
in order to generate trace files at execution time.
This step is called <SPAN  CLASS="textit">instrumentation</SPAN>.
It furthermore explains how to control the runtime measurement system 
during execution (<SPAN  CLASS="textit">tracing</SPAN>). 
This also includes performance counter sampling
as well as selective filtering and grouping of functions.

<P>

<P>

<H1><A NAME="SECTION00200000000000000000">
Introduction</A>
</H1>

<P>
VampirTrace consists of a tool set and a runtime library for instrumentation 
and tracing of software applications. It is particularly tailored to
parallel and distributed High Performance Computing (HPC) applications.

<P>
The instrumentation part modifies a given application in order to inject
additional measurement calls during runtime. The tracing part provides 
the actual measurement functionality used by the instrumentation calls.
By this means, a variety of detailed performance properties can be collected 
and recorded during runtime. 
This includes function enter and leave events, MPI communication,
OpenMP events, and performance counters.

<P>
After a successful tracing run, VampirTrace writes all collected data to a  
trace file in the Open Trace Format (OTF)<A NAME="tex2html3"
  HREF="#foot1144"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.
As a result, the information is available for post-mortem analysis and 
visualization by various tools. 
Most notably, VampirTrace provides the input data for the Vampir analysis  
and visualization tool<A NAME="tex2html5"
  HREF="#foot1145"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>. 

<P>
VampirTrace is included in OpenMPI&nbsp;1.3 and later versions.
If not disabled explicitly, VampirTrace is built automatically when installing
OpenMPI<A NAME="tex2html7"
  HREF="#foot1146"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.

<P>
Trace files can quickly become very large, especially with automatic instrumentation.
Tracing applications for only a few seconds can result in 
trace files of several hundred megabytes. To protect users from 
creating trace files of several gigabytes, the default behavior of 
VampirTrace limits the internal buffer to 32 MB per process. Thus, even for larger
scale runs the total trace file size will be moderate.
Please read Section&nbsp;<A HREF="#sec:trace_file_size">3.3</A> on how to remove or change this limit. 

<P>
VampirTrace supports various Unix and Linux platforms that are common in  
HPC nowadays. It is available as open source software under a BSD License.  

<P>
The following list shows a summary of all instrumentation and tracing features
that VampirTrace offers.
Note that not all features are supported on all platforms.

<P>
<BR>
<BR>

<P>

<P>
 <SPAN  CLASS="textbf">Tracing of user functions</SPAN>  &#8658; Chapter&nbsp;<A HREF="#chap:instrumentation">2</A> <BR>

<UL>
<LI>Record function enter and leave events
</LI>
<LI>Record name and source code location (file name, line)
</LI>
<LI>Various kinds of instrumentation &#8658; Section&nbsp;<A HREF="#sec:instrumentation_types">2.2</A> 

<UL>
<LI>Automatic with many compilers &#8658; Section&nbsp;<A HREF="#sec:compinst">2.3</A> 
</LI>
<LI>Manual using VampirTrace API &#8658; Section&nbsp;<A HREF="#sec:maninst">2.4</A> 
</LI>
<LI>Automatic with tau_instrumentor &#8658; Section&nbsp;<A HREF="#sec:tauinst">2.5</A> 
</LI>
<LI>Automatic with Dyninst &#8658; Section&nbsp;<A HREF="#sec:dyninst">2.6</A> 
</LI>
</UL>
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">MPI Tracing</SPAN>  &#8658; Chapter&nbsp;<A HREF="#chap:instrumentation">2</A>  <BR>

<UL>
<LI>Record MPI functions
</LI>
<LI>Record MPI communication: participating processes, transferred bytes, tag, communicator
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">OpenMP Tracing</SPAN>  &#8658; Chapter&nbsp;<A HREF="#chap:instrumentation">2</A>  <BR>

<UL>
<LI>OpenMP directives, synchronization, thread idle time
</LI>
<LI>Also hybrid (MPI and OpenMP) applications are supported
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">Pthread Tracing</SPAN>

<UL>
<LI>Trace POSIX thread API calls &#8658; Section&nbsp;<A HREF="#sec:pthread_calls">4.6</A>
</LI>
<LI>Also hybrid (MPI and POSIX threads) applications are supported
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">Java Tracing</SPAN>  &#8658; Section&nbsp;<A HREF="#sec:jvmti">2.8</A>  <BR>

<UL>
<LI>Record method calls
</LI>
<LI>Using JVMTI as interface between VampirTrace and Java Applications
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">3rd-Party Library tracing</SPAN> &#8658; Section&nbsp;<A HREF="#sec:3rd-party">2.9</A>  <BR>

<UL>
<LI>Trace calls to arbitrary third party libraries
</LI>
<LI>Generate wrapper for library functions based on library's header file(s)
</LI>
<LI>No recompilation of application or library is required
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">MPI Correctness Checking</SPAN> &#8658; Section&nbsp;<A HREF="#sec:unimci">4.10</A> <BR>

<UL>
<LI>Record MPI usage errors
</LI>
<LI>Using UniMCI as interface between VampirTrace and a MPI correctness checking tool (e.g. Marmot)
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">User API</SPAN> <BR>

<UL>
<LI>Manual instrumentation of source code regions &#8658; Section&nbsp;<A HREF="#sec:maninst">2.4</A>
</LI>
<LI>Measurement controls &#8658; Section&nbsp;<A HREF="#subsec:measurement_controls">2.4.2</A>
</LI>
<LI>User-defined counters &#8658; Section&nbsp;<A HREF="#sec:userdefinedcounters">4.11</A>
</LI>
<LI>User-defined marker &#8658; Section&nbsp;<A HREF="#sec:userdefinedmarkers">4.12</A>
</LI>
<LI>User-defined communication &#8658; Section&nbsp;<A HREF="#sec:userdefinedcomm">4.13</A>
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">Performance Counters</SPAN>  &#8658; Sections&nbsp;<A HREF="#sec:hw_perf_counters">4.1</A> and&nbsp;<A HREF="#sec:rusage_counters">4.2</A>  <BR>

<UL>
<LI>Hardware performance counters using PAPI, CPC, or NEC SX performance counter
</LI>
<LI>Resource usage counters using getrusage
</LI>
</UL> 

<P>
 <SPAN  CLASS="textbf">Memory Tracing</SPAN>  &#8658; Section&nbsp;<A HREF="#sec:mem_alloc_counter">4.3</A>  <BR>

<UL>
<LI>Trace GLIBC memory allocation and free functions
</LI>
<LI>Record size of currently allocated memory as counter
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">I/O Tracing</SPAN>  &#8658; Section&nbsp;<A HREF="#sec:io_calls">4.8</A>  <BR>

<UL>
<LI>Trace LIBC I/O calls
</LI>
<LI>Record I/O events: file name, transferred bytes
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">CPU ID Tracing</SPAN>  &#8658; Section&nbsp;<A HREF="#sec:cpu_id_counter">4.4</A>  <BR>

<UL>
<LI>Trace core ID of a CPU on which the calling thread is running
</LI>
<LI>Record core ID as counter
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">Fork/System/Exec Tracing</SPAN>  &#8658; Section&nbsp;<A HREF="#sec:execfork">4.9</A> <BR>

<UL>
<LI>Trace applications calling LIBC's fork, system, or one of the exec functions
</LI>
<LI>Add forked processes to the trace
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">Filtering &amp; Grouping</SPAN>  &#8658; Chapter&nbsp;<A HREF="#filtering_and_grouping">5</A> <BR>

<UL>
<LI>Runtime and post-mortem filter (i.e.&nbsp;exclude functions from being recorded in the trace)
</LI>
<LI>Runtime grouping (i.e.&nbsp;assign functions to groups for improved analysis)
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">OTF Output</SPAN>  &#8658; Chapter&nbsp;<A HREF="#chap:runtime_measurement">3</A> <BR>

<UL>
<LI>Writes compressed OTF files
</LI>
<LI>Output as trace file, statistical summary (profile), or both
</LI>
</UL>

<P>

<H1><A NAME="SECTION00300000000000000000"></A>
<A NAME="chap:instrumentation"></A>
<BR>
Instrumentation
</H1>

<P>
To perform measurements with VampirTrace, the user's application program needs to
be instrumented, i.e., at specific points of interest (called ``events'') VampirTrace
measurement calls have to be activated.
As an example, common events are, amongst others, entering and leaving 
of functions as well as sending and receiving of MPI messages.

<P>
VampirTrace handles this automatically by default. In order to enable the
instrumentation of function calls, the user only needs to replace the compiler 
and linker commands with VampirTrace's wrappers, 
see Section&nbsp;<A HREF="#sec:compiler_wrappers">2.1</A> below. 
VampirTrace supports different ways of instrumentation as described in 
Section&nbsp;<A HREF="#sec:instrumentation_types">2.2</A>.

<P>

<H1><A NAME="SECTION00310000000000000000"></A>
<A NAME="sec:compiler_wrappers"></A>
<BR>
Compiler Wrappers
</H1>

<P>
All the necessary instrumentation of user functions, MPI, and
OpenMP events is handled by VampirTrace's compiler wrappers (vtcc, vtcxx, vtf77, and
vtf90).
In the script used to build the application (e.g.&nbsp;a makefile), all compile
and link commands should be replaced by the VampirTrace compiler wrapper.
The wrappers perform the necessary instrumentation of the program and link
the suitable VampirTrace library.
Note that the VampirTrace version included in OpenMPI&nbsp;1.3
has additional wrappers (mpicc-vt, mpicxx-vt, mpif77-vt, and mpif90-vt) which
are like the ordinary MPI compiler wrappers (mpicc, mpicxx, mpif77, and mpif90)
with the extension of automatic instrumentation.

<P>
The following list shows some examples specific to the parallelization
type of the program:

<P>

<UL>
<LI><SPAN  CLASS="textbf">Serial programs</SPAN>:
Compiling serial codes is the default behavior of the wrappers.
Simply replace the compiler by VampirTrace's wrapper:

<P>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">original:</TD>
<TD ALIGN="LEFT"><TT>gfortran hello.f90 -o hello  </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">with instrumentation:</TD>
<TD ALIGN="LEFT"><TT><SPAN  CLASS="textbf">vtf90</SPAN> hello.f90 -o hello  </TT></TD>
</TR>
</TABLE>
<BR>

<P>
This will instrument user functions (if supported by the compiler) and
link the VampirTrace library.

<P>
</LI>
<LI><SPAN  CLASS="textbf">MPI parallel programs</SPAN>:
MPI instrumentation is always handled by means of the PMPI interface, 
which is part of the MPI standard.
This requires the compiler wrapper to link with an MPI-aware version of
the VampirTrace library.
If your MPI implementation uses special MPI compilers (e.g.&nbsp;mpicc, mpxlf90),
you will need to tell VampirTrace's wrapper to use this compiler
instead of the serial one:

<P>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">original:</TD>
<TD ALIGN="LEFT"><TT>mpicc hello.c -o hello  </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">with instrumentation:</TD>
<TD ALIGN="LEFT"><TT><SPAN  CLASS="textbf">vtcc -vt:cc mpicc</SPAN> hello.c -o hello  </TT></TD>
</TR>
</TABLE>
<BR>

<P>
MPI implementations without own compilers require the user to link
the MPI library manually. In this case, simply replace the compiler
by VampirTrace's compiler wrapper:

<P>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">original:</TD>
<TD ALIGN="LEFT"><TT>icc hello.c -o hello -lmpi </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">with instrumentation:</TD>
<TD ALIGN="LEFT"><TT><SPAN  CLASS="textbf">vtcc</SPAN> hello.c -o hello -lmpi  </TT></TD>
</TR>
</TABLE>
<BR>

<P>
If you want to instrument MPI events only (this creates smaller trace files and less overhead)
use the option <TT>-vt:inst manual</TT> to disable automatic instrumentation
of user functions (see also Section&nbsp;<A HREF="#sec:maninst">2.4</A>).

<P>
</LI>
<LI><SPAN  CLASS="textbf">Threaded parallel programs</SPAN>:
When VampirTrace detects OpenMP or 
<BR>
Pthread flags on the command line, special instrumentation 
calls are invoked. For OpenMP events OPARI is invoked for automatic source code instrumentation.

<P>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">original:</TD>
<TD ALIGN="LEFT"><TT>ifort &lt;-openmp|-pthread&gt; hello.f90 </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><TT>-o hello </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">with instrumentation:</TD>
<TD ALIGN="LEFT"><TT><SPAN  CLASS="textbf">vtf90</SPAN> &lt;-openmp|-pthread&gt; hello.f90 </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><TT>-o hello </TT></TD>
</TR>
</TABLE>
<BR>

<P>
For more information about OPARI read the documentation available in VampirTrace's installation
directory at:
<TT>share/vampirtrace/doc/opari/Readme.html</TT> 

<P>
</LI>
<LI><SPAN  CLASS="textbf">Hybrid MPI/Threaded parallel programs</SPAN>:
With a combination of the  above mentioned approaches, hybrid applications can be instrumented:

<P>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">original:</TD>
<TD ALIGN="LEFT"><TT>mpif90 &lt;-openmp|-pthread&gt; hello.F90 </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><TT>-o hello </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">with instrumentation:</TD>
<TD ALIGN="LEFT"><TT><SPAN  CLASS="textbf">vtf90 -vt:f90 mpif90</SPAN> </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><TT>&lt;-openmp|-pthread&gt; hello.F90</TT></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><TT>-o hello </TT></TD>
</TR>
</TABLE>
<BR>

<P>
</LI>
</UL>

<P>
The VampirTrace compiler wrappers automatically try to detect which parallelization
method is used by means of the compiler flags (e.g.&nbsp;<TT>-lmpi</TT>,&nbsp;<TT>-openmp</TT> 
or <TT>-pthread</TT>) and the compiler command (e.g.&nbsp;<TT>mpif90</TT>).
If the compiler wrapper failed to detect this correctly,
the instrumentation could be incomplete and an unsuitable
VampirTrace library would be linked to the binary.
In this case, you should tell the compiler wrapper which parallelization method
your program uses by using the switches
<TT>-vt:mpi</TT>, <TT>-vt:mt</TT>, and <TT>-vt:hyb</TT> for MPI, multithreaded, and
hybrid programs, respectively.
Note that these switches do not change the underlying compiler or compiler flags.
Use the option <TT>-vt:verbose</TT> to see the command line that the compiler wrapper 
executes. See Section&nbsp;<A HREF="#sec:comm_wrappers">B.1</A> for a list of all compiler wrapper options.

<P>
The default settings of the compiler wrappers can be modified in the files
<TT>share/vampirtrace/vtcc-wrapper-data.txt</TT> (and similar for the other languages)
in the installation directory of VampirTrace.
The settings include compilers, compiler flags, libraries, and instrumentation types.
You could for instance modify the default C compiler 
from <TT>gcc</TT>
to <TT>mpicc</TT> by changing the line <TT>compiler=gcc</TT> to <TT>compiler=mpicc</TT>.
This may be convenient if you instrument MPI parallel programs only.

<P>

<H1><A NAME="SECTION00320000000000000000"></A>
<A NAME="sec:instrumentation_types"></A>
<BR>
Instrumentation Types
</H1>

<P>
The wrapper option <TT>-vt:inst &lt;insttype&gt;</TT> specifies the 
instrumentation type to be used. The following values for 
<TT>&lt;insttype&gt;</TT> are possible:

<P>

<UL>
<LI><TT>compinst</TT> 
<BR>
Fully-automatic instrumentation by the compiler (&#8658; Section&nbsp;<A HREF="#sec:compinst">2.3</A>)

<P>
</LI>
<LI><TT>manual</TT> 
<BR>
Manual instrumentation by using VampirTrace's API (&#8658; Section&nbsp;<A HREF="#sec:maninst">2.4</A>) 
<BR>(needs source-code modifications)

<P>
</LI>
<LI><TT>tauinst</TT> 
<BR>
Fully-automatic instrumentation by the tau_instrumentator (&#8658; Section&nbsp;<A HREF="#sec:tauinst">2.5</A>)

<P>
</LI>
<LI><TT>dyninst</TT> 
<BR>
Binary-instrumentation with Dyninst (&#8658; Section&nbsp;<A HREF="#sec:dyninst">2.6</A>)

<P>
</LI>
</UL>

<P>
To determine which instrumentation type will be used by default and which instrumentation
types are available on your system have a look at the entry <TT>inst_avail</TT> in the
wrapper's configuration file (e.g.&nbsp;<TT>share/vampirtrace/vtcc-wrapper-data.txt</TT> in the
installation directory of VampirTrace for the C compiler wrapper).

<P>
See Section&nbsp;<A HREF="#sec:comm_wrappers">B.1</A> or type <TT>vtcc -vt:help</TT> for other
options that can be passed to VampirTrace's compiler wrapper.

<P>

<H1><A NAME="SECTION00330000000000000000"></A>
<A NAME="sec:compinst"></A>
<BR>
Automatic Instrumentation
</H1>

<P>
Automatic instrumentation is the most convenient method to instrument your program.
If available, simply use the compiler wrappers without any parameters, e.g.:

<P>
<BR>
<BR>
<code>   % vtf90 hello.f90 -o hello</code>
<BR>

<P>

<H2><A NAME="SECTION00331000000000000000">
Supported Compilers</A>
</H2>
VampirTrace supports following compilers for automatic instrumentation:

<P>

<UL>
<LI>GNU (i.e.&nbsp;gcc, g++, gfortran, g95)
</LI>
<LI>Intel version &#8805;10.0 (i.e.&nbsp;icc, icpc, ifort)
</LI>
<LI>PathScale version &#8805;3.1 (i.e.&nbsp;pathcc, pathCC, pathf90)
</LI>
<LI>Portland Group (PGI) (i.e.&nbsp;pgcc, pgCC, pgf90, pgf77)
</LI>
<LI>SUN Fortran 90 (i.e.&nbsp;cc, CC, f90)
</LI>
<LI>IBM (i.e.&nbsp;xlcc, xlCC, xlf90)
</LI>
<LI>NEC SX (i.e.&nbsp;sxcc, sxc++, sxf90)
</LI>
<LI>OpenUH version &#8805;4.0 (i.e.&nbsp;uhcc, uhCC, uhf90)
</LI>
</UL>

<P>

<H2><A NAME="SECTION00332000000000000000"></A>
<A NAME="subsec:nmnotes"></A>
<BR>
Notes for Using the GNU, Intel, or PathScale Compiler
</H2>
For these compilers the command <TT>nm</TT> is required to get symbol information
of the running application executable. For example on Linux systems, this program is a
part of the <SPAN  CLASS="textit">GNU Binutils</SPAN>, which is downloadable from
<TT><A NAME="tex2html9"
  HREF="http://www.gnu.org/software/binutils">http://www.gnu.org/software/binutils</A></TT>.

<P>
To get the application executable for <TT>nm</TT> during runtime, VampirTrace uses the
<TT>/proc</TT> file system. As <TT>/proc</TT> is not present on all operating systems,
automatic symbol information might not be available. In this case, it is necessary to set
the environment variable <TT>VT_APPPATH</TT> to the pathname of the application executable
to get symbols resolved via <TT>nm</TT>.

<P>
Should any problems emerge to get symbol information automatically, then the environment
variable <TT>VT_GNU_NMFILE</TT> can be set to a symbol list file, which is created with the
command <TT>nm</TT>, like:

<P>
<BR>
<BR>
<code>   % nm hello &gt; hello.nm</code>
<BR>
<BR>
<BR>
To get the source code line for the application functions use <TT>nm -l</TT> on Linux systems.
VampirTrace will include this information into the trace.
Note that the output format of <TT>nm</TT> must be written in BSD-style. See the manual page
of <TT>nm</TT> to obtain help for dealing with the output format setting.

<P>

<H2><A NAME="SECTION00333000000000000000"></A>
<A NAME="subsec:inlinenotes"></A>
<BR>
Notes on Instrumentation of Inline Functions
</H2>
Compilers behave differently when they automatically instrument inlined functions.
The GNU and Intel &#8805;10.0 compilers instrument all functions by default when they
are used with VampirTrace. They therefore switch off inlining completely, disregarding
the optimization level chosen.
One can prevent these particular functions from being instrumented by appending the
following attribute to function declarations, hence
making them able to be inlined (this works only for C/C++):

<P>
<BR>
<BR>
<code>      __attribute__ ((__no_instrument_function__))</code>
<BR>
<BR>

<P>
The PGI and IBM compilers prefer inlining over instrumentation when compiling
with enabled inlining. Thus, one needs to disable inlining to enable the instrumentation
of inline functions and vice versa.

<P>
The bottom line is that a function cannot be inlined and instrumented at the same time.
For more information on how to inline functions read your compiler's manual.

<P>

<H2><A NAME="SECTION00334000000000000000"></A>
<A NAME="subsec:openuh_loop"></A>
<BR>
Instrumentation of Loops with OpenUH Compiler
</H2>
The OpenUH compiler provides the possibility of instrumenting loops in addition to functions.
To use this functionality add the compiler flag <TT>-OPT:instr_loop</TT>. In this
case loops induce additional events including the type of loop (e.g. for, while, or do)
and the source code location.

<P>

<H1><A NAME="SECTION00340000000000000000"></A>
<A NAME="sec:maninst"></A>
<BR>
Manual Instrumentation
</H1>

<H2><A NAME="SECTION00341000000000000000">
Using the VampirTrace API</A>
</H2>

<P>
The <TT>VT_USER_START</TT>, <TT>VT_USER_END</TT> calls 
can be used to instrument any user-defined sequence of statements. 

<P>
<PRE>
Fortran: 
           #include "vt_user.inc"
           VT_USER_START('name')
           ...
           VT_USER_END('name')
</PRE> 

<P>
<PRE>
C:
           #include "vt_user.h"
           VT_USER_START("name");
           ...
           VT_USER_END("name");
</PRE>
If a block has several exit points (as it is often the case for
functions), all exit points have to be instrumented with 
<TT>VT_USER_END</TT>, too.

<P>
For C++ it is simpler as is demonstrated in the following example. Only entry points into a 
scope need to be marked. The exit points are detected automatically when C++ 
deletes scope-local variables.

<P>
<PRE>
C++:
           #include "vt_user.h"
           {
             VT_TRACER("name");
             ...
           }
</PRE> 

<P>
The instrumented sources have to be compiled with <TT>-DVTRACE</TT> for
  all three languages, otherwise the <TT>VT_*</TT> calls are ignored. 
  Note that Fortran source files instrumented this way have to be 
  preprocessed, too.

<P>
In addition, you can combine this particular instrumentation type with all other types.
  In such a way, all user functions can be instrumented by a compiler while
  special source code regions (e.g.&nbsp;loops) can be instrumented by VT's API.

<P>
Use VT's compiler wrapper (described above) for compiling and linking the
  instrumented source code, such as:

<UL>
<LI>combined with automatic compiler instrumentation:
<BR>
<BR><TT>% vtcc <SPAN  CLASS="textbf">-DVTRACE</SPAN> hello.c -o hello</TT>
<BR>
<BR>
</LI>
<LI>without compiler instrumentation:
<BR>
<BR><TT>% vtcc -vt:inst manual <SPAN  CLASS="textbf">-DVTRACE</SPAN> hello.c -o hello</TT>
<BR>
<BR>
</LI>
</UL>

<P>
Note that you can also use the option <TT>-vt:inst manual</TT>
  with non-instrumented sources.
  Binaries created in this manner only contain MPI and OpenMP instrumentation,
  which might be desirable in some cases.

<P>

<H2><A NAME="SECTION00342000000000000000"></A>
<A NAME="subsec:measurement_controls"></A>
<BR>
Measurement Controls
</H2>

<P>

<H4><A NAME="SECTION00342010000000000000">
Switching tracing on/off:</A>
</H4>
  In addition to instrumenting arbitrary blocks of code, one can use the
  <TT>VT_ON</TT>/ <TT>VT_OFF</TT> instrumentation calls to start and stop
  the recording of events. These constructs can be used to stop recording
  of events for a part of the application and later resume recording. For
  example, one could not collect trace events during the initialization phase
  of an application and turn on tracing for the computation part.

<P>
Furthermore the "on/off" functionality can be used to control the 
  tracing behavior of VampirTrace and allows to trace only parts of interests.
  Therefore the amount of trace data can be reduced essentially.
  To check whether if tracing is enabled or not use the call <TT>VT_IS_ON</TT>.

<P>
For further information about limitations have a look at the FAQ <A HREF="#sec:faq_onoff">D.5</A>.

<P>

<H4><A NAME="SECTION00342020000000000000">
Trace buffer rewind:</A>
</H4>
  An alternative to the "on/off" functionality is the buffer rewind
  approach. It is useful when the program should decide dynamically <SPAN  CLASS="textit">after</SPAN> a
  specific code section (i.e. a time step or iteration) if this section
  <SPAN  CLASS="textit">has been</SPAN> interesting (i.e. anomalous/slow behavior) and should be
  recorded to the trace file.
  The key difference to "on/off" is that you do not need to know a priori if a section
  should be recorded.

<P>
Use the instrumentation call <TT>VT_SET_REWIND_MARK</TT> at the beginning of
  a (possibly not interesting) code section.
  Later, you can decide to rewind the trace buffer to the mark with the call  
  <TT>VT_REWIND</TT>.
  All recorded trace data between the mark and the rewind call will be dropped.
  Note, that only one mark can be set at a time. The last call to
  <TT>VT_SET_REWIND_MARK</TT> will be considered when rewinding the trace buffer.
  This simplified Fortran code example sketches show the rewind approach can be used:
<PRE>
           do step=1,number_of_time_steps
             VT_SET_REWIND_MARK()
             call compute_time_step(step)
             if(finished_as_expected) VT_REWIND()
           end do
</PRE>
  Refer to FAQ <A HREF="#sec:faq_onoff">D.5</A> for limitations associated with this method.

<P>

<H4><A NAME="SECTION00342030000000000000">
Intermediate buffer flush:</A>
</H4>
  In addition to an automated buffer flush when the buffer is filled, it is
  possible to flush the buffer at any point of the application. This way you can
  guarantee that after a manual buffer flush there will be a sequence of the program
  with no automatic buffer flush interrupting. To flush the buffer you can use the
  call <TT>VT_BUFFER_FLUSH</TT>.

<P>

<H4><A NAME="SECTION00342040000000000000">
Intermediate time synchronisation:</A>
</H4>
  VampirTrace provides several mechanisms for timer synchronization (&#8658;   Section&nbsp;<A HREF="#sec:timer_synchronization">3.7</A>). In addition it is also possible to
  initiate a timer synchronization at any point of the application by calling
  <TT>VT_TIMESYNC</TT>. Please note that the user has to ensure that all
  processes are actual at a synchronized point in the program (e.g. at a barrier).
  To use this call make sure that the enhanced timer synchronization is activated
  (set the environment variable <TT>VT_ETIMESYNC</TT> &#8658; Section&nbsp;<A HREF="#sec:env_variables">3.2</A>). 

<P>

<H4><A NAME="SECTION00342050000000000000">
Intermediate counter update:</A>
</H4> 
  VampirTrace provides the functionality to collect the values of arbitrary
  hardware counters. Chosen counter values are automatically recorded whenever
  an event occurs. Sometimes (e.g. within a long-lasting function) it is desirable
  to get the counter values at an arbitrary point within the program. To record
  the counter values at any given point you can call <TT>VT_UPDATE_COUNTER</TT>.

<P>

<H4><A NAME="SECTION00342060000000000000">
Note:</A>
</H4>
  For all three languages the instrumented sources have to be compiled 
  with <TT>-DVTRACE</TT>. Otherwise the <TT>VT_*</TT> calls are ignored.
<BR>
In addition, if the sources contains further VampirTrace API calls and only the
  calls for measurement controls shall be disabled, then the sources have to be
  compiled with <TT>-DVTRACE_NO_CONTROL</TT>, too.

<P>

<H1><A NAME="SECTION00350000000000000000"></A>
<A NAME="sec:tauinst"></A>
<BR>
Source Instrumentation Using PDT/TAU
</H1>
  TAU instrumentation combines the advantages of compiler and manual instrumentation and has further advantages.
  Like compiler instrumentation it works automatically, like on manual instrumentation you have a filtered set of events,
  this is especially recommended for C++, because STL-constructor calls are suppressed.
  Unlike with compiler instrumentation you get an optimized binary - this solves the issue described in Section <A HREF="#subsec:inlinenotes">2.3.3</A>.
  In the simpliest case you just run the compiler wrappers with <TT>-vt:inst tauinst</TT> option:

<P>
<BR>
<BR>
<code>   % vtcc -vt:inst tauinst hello.c -o hello</code>
<BR>
<BR>

<P>
There is a known issue with the TAU instrumentation in the &#8658;&nbsp;FAQ <A HREF="#sec:faq_asm_error">D.9</A>

<H4><A NAME="SECTION00350010000000000000">
Requirements for TAU instrumentation:</A>
</H4>
  To work with TAU instrumenation you need the Program Database Toolkit.
  You have to make sure, to have <TT>cparse</TT> and <TT>tau_instrumentor</TT> in your <TT>$PATH</TT>. 
  The PDToolkit can be downloaded from <TT><A NAME="tex2html10"
  HREF="http://www.cs.uoregon.edu/research/pdt/home.php">http://www.cs.uoregon.edu/research/pdt/home.php</A></TT>.

<H4><A NAME="SECTION00350020000000000000">
Include/Exclude Lists:</A>
</H4>
  <TT>tau_instrumentor</TT> provides a mechanism to include and exclude files or functions
  from instrumenation. The lists are deposed
<BR>
in a single file, that 
  is announced to <TT>tau_instrumentor</TT> via the option
<BR><TT>-f=&lt;filename&gt;</TT>.
  This file contains up to four lists which begin with
<BR><TT>BEGIN[_FILE]_&lt;INCLUDE|EXCLUDE&gt;_LIST</TT>.
  The names in between may contain wildcards as ``?'', ``*', and ``#'', each entry gets a new line.
  The lists end with <TT>END[_FILE]_&lt;INCLUDE|EXCLUDE&gt;_LIST</TT>. For further information on selective 
  profiling have a look at the TAU documentation<A NAME="tex2html11"
  HREF="#foot1170"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.
  To announce the file through the compiler wrapper use the option <TT>-vt:tau</TT>:
<PRE>
   % vtcc -vt:inst tauinst hello.c -o hello \
     -vt:tau -f=&lt;filename&gt;
</PRE>
<H1><A NAME="SECTION00360000000000000000"></A>
<A NAME="sec:dyninst"></A>
<BR>
Binary Instrumentation Using Dyninst
</H1>

<P>
The option <TT>-vt:inst dyninst</TT> is used with the compiler wrapper to 
instrument the application during runtime (binary instrumentation), by using 
Dyninst<A NAME="tex2html13"
  HREF="#foot1171"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.
Recompiling is not necessary for this kind of instrumentation,
but relinking:

<P>
<BR>
<BR>
<code>   % vtf90 -vt:inst dyninst hello.o -o hello</code>
<BR>
<BR>
<BR>
The compiler wrapper dynamically links the library <TT>libvt-dynatt.so</TT>
  to the  application. This library attaches the <SPAN  CLASS="textit">mutator</SPAN>-program
  <TT>vtdyn</TT> during runtime which invokes the instrumentation by using Dyninst.

<P>
To prevent certain functions from being instrumented you can use the runtime function
  filtering as explained in Section&nbsp;<A HREF="#sec:function_filter">5.1</A>. All additional overhead,
  due to instrumentation of these functions, will be removed.

<P>
VampirTrace also allows binary instrumentation of functions located in shared libraries.
  For this to work a colon-separated list of shared library names has to be given in
  the environment variable <TT>VT_DYN_SHLIBS</TT>:

<P>
<BR>
<BR>
  <code>   VT_DYN_SHLIBS=libsupport.so:libmath.so</code>
  <BR>
<BR>

<P>

<H2><A NAME="SECTION00361000000000000000"></A>
<A NAME="sec:static_dyninst"></A>
<BR>
Static Binary Instrumentation
</H2>
In order to avoid the overhead introduced by Dyninst during runtime, the tool 
<TT>vtdyn</TT> can be used for binary instrumentation before application launch.
To accomplish this, the <TT>-o</TT> or <TT>-output</TT> switch can be used to 
specify the output binary. Note that the application must be linked to the corresponding
VampirTrace library.

<P>

<H4><A NAME="SECTION00361010000000000000">
Example</A>
</H4> 
To apply binary instrumentation to the executable <TT>a.out</TT> the following 
command is nescessary:

<P>
<BR>
<BR>
<code>	% vtdyn -o dyninst_a.out ./a.out</code>
<BR>
<BR>

<P>

<H1><A NAME="SECTION00370000000000000000"></A>
<A NAME="sec:runtime_instrumentation"></A>
<BR>
Runtime Instrumentation Using VTRun
</H1>
Besides the already described instrumentation at compile-time, VampirTrace also 
supports runtime instrumention using the <TT>vtrun</TT> command. Prepending the actual
call to the application will transparently add instrumentation support and launch the 
application. This includes support for function instrumentation as well as MPI 
communication tracing. By default, <TT>vtrun</TT> tries to apply MPI instrumentation first.
If the application does not utilize MPI, the tool tries to use Dyninst
(Section&nbsp;<A HREF="#sec:dyninst">2.6</A>) for instrumenting function calls which requires 
VampirTrace being built with Dyninst support. In order to enable instrumentation for 
both MPI and user functions the user has to specify the <TT>-dyninst</TT> 
command line switch.

<P>

<H4><A NAME="SECTION00370010000000000000">
Example</A>
</H4>
In order to add tracing support to an already existing executable, only a small change to 
the startup command has to be made. Assuming the usual way of calling the 
application looks like:

<P>
<BR>
<BR>
<code>	% mpirun -np 4 ./a.out </code>
<BR>
<BR>

<P>
By putting the call to <TT>vtrun</TT> directly before the actual application call, instrumention 
support will be enabled at runtime:

<P>
<BR>
<BR>
<code>	% mpirun -np 4 vtrun ./a.out</code>
<BR>
<BR>

<P>
For more information about the tool <TT>vtrun</TT> see Section&nbsp;<A HREF="#sec:VTRUN">B.6</A>.

<P>

<H1><A NAME="SECTION00380000000000000000"></A>
<A NAME="sec:jvmti"></A>
<BR>
Tracing Java Applications Using JVMTI
</H1>
  In addition to C, C++, and Fortran, VampirTrace is capable of tracing Java
  applications. This is accomplished by means of the Java Virtual Machine Tool
  Interface (JVMTI) which is part of JDK versions 5 and later.
  If VampirTrace was built with Java tracing support, the library <TT>libvt-java.so</TT>
  can be used as follows to trace any Java program: 

<P>
<BR>
<BR>
  <code>   % java -agentlib:vt-java ...</code>
  <BR>
<BR>

<P>
Or more easier, by replacing the usal Java application launcher <TT>java</TT> by the command <TT>vtjava</TT>:

<P>
<BR>
<BR>
  <code>  % vtjava ...                 </code>
  <BR>
<BR>

<P>
When tracing Java applications, you probably want to filter out dispensable
  function calls. Please have a look at Sections&nbsp;<A HREF="#sec:function_filter">5.1</A>
  and&nbsp;<A HREF="#sec:java_filter">5.2</A> to learn about different ways for excluding parts of the
  application from tracing.

<P>

<H1><A NAME="SECTION00390000000000000000"></A>
<A NAME="sec:3rd-party"></A>
<BR>
Tracing Calls to 3rd-Party Libraries
</H1>
  VampirTrace is also capable to trace calls to third party libraries, which come with
  at least one C header file even without the library's source code. If VampirTrace was
  built with support for library tracing (the CTool library is required), 
  the tool <TT>vtlibwrapgen</TT> can be used to
  generate a wrapper library to intercept each call to the actual library functions.
  This wrapper library can be linked to the application or used in combination with the
  <TT>LD_PRELOAD</TT> mechanism provided by Linux.
  The generation of a wrapper library is done using the <TT>vtlibwrapgen</TT> 
  command and consists of two steps. The first step generates a C source file, 
  providing the wrapped functions of the library header file:

<P>
<BR>
<BR>
  <code>  % vtlibwrapgen -g SDL -o SDLwrap.c /usr/include/SDL/*.h</code>
  <BR>
<BR>

<P>
This generates the source file <TT>SDLwrap.c</TT> that contains wrapper-functions for
  all library functions found in the header-files located in /usr/include/SDL/ and
  instructs VampirTrace to assign these functions to the new group <TT>SDL</TT>.

<P>
The generated wrapper source file can be edited in order to add manual instrumentation
  or alter attributes of the library wrapper. A detailed description can be found in the 
  generated source file or in the header file <TT>vt_libwrap.h</TT> which can be found in the 
  include directory of VampirTrace.

<P>
To adapt the library instrumentation it is possible to pass a filter file to
  the generation process. The rules are like these for normal VampirTrace instrumentation
  (see Section&nbsp;<A HREF="#sec:function_filter">5.1</A>), where only 0 (exclude functions) and -1 (generally include
  functions) are allowed.
<BR>
<P>
The second step is to compile the generated source file:

<P>
<BR>
<BR>
  <code>  % vtlibwrapgen --build --shared -o libSDLwrap SDLwrap.c</code>
  <BR>
<BR>

<P>
This builds the shared library <TT>libSDLwrap.so</TT> which can be linked to the application
  or preloaded by using the environment variable <TT>LD_PRELOAD</TT>:

<P>
<BR>
<BR>
  <code>  % LD_PRELOAD=$PWD/libSDLwrap.so &lt;executable&gt;</code>
  <BR>
<BR>

<P>
For more information about the tool <TT>vtlibwrapgen</TT> see Section&nbsp;<A HREF="#sec:VTLIBWRAPGEN">B.5</A>.

<P>

<H1><A NAME="SECTION00400000000000000000"></A>
<A NAME="chap:runtime_measurement"></A>
<BR>
Runtime Measurement
</H1>

<P>
Running a VampirTrace instrumented application should normally result in an
OTF trace file in the current working directory where the application was
executed. If a problem occurs, set the environment variable
<TT>VT_VERBOSE</TT> to <TT>2</TT> before executing the instrumented application
in order to see control messages of the VampirTrace runtime system which might
help tracking down the problem.

<P>
The internal buffer of VampirTrace is limited to 32 MB per process. Use the environment
variables <TT>VT_BUFFER_SIZE</TT> and <TT>VT_MAX_FLUSHES</TT> to increase
this limit. Section&nbsp;<A HREF="#sec:trace_file_size">3.3</A> contains further information on
how to influence trace file size.

<P>

<H1><A NAME="SECTION00410000000000000000"></A>
<A NAME="sec:tracefilename"></A>
<BR>
Trace File Name and Location
</H1>

<P>
The default name of the trace file depends on the operating system where the
application is run. On Linux, MacOS and Sun Solaris the trace file will
be named like the application, e.g.&nbsp;<TT>hello.otf</TT> for the executable <TT>hello</TT>.
For other systems, the default name is <TT>a.otf</TT>.
Optionally, the trace file name can be defined manually by setting the environment
variable <TT>VT_FILE_PREFIX</TT> to the desired name. The suffix <TT>.otf</TT>
will be added automatically.

<P>
To prevent overwriting of trace files by repetitive program runs,
one can enable unique trace file naming by setting <TT>VT_FILE_UNIQUE</TT> to <TT>yes</TT>.
In this case, VampirTrace adds a unique number to the file names as soon as a second
trace file with the same name is created.
A <TT>*.lock</TT> file is used to count up the number of trace files in a directory.
Be aware that VampirTrace potentially overwrites an existing trace file
if you delete this lock file.
The default value of <TT>VT_FILE_UNIQUE</TT> is <TT>no</TT>.
You can also set this variable to a number greater than zero,
which will be added to the trace file name. This way you can manually control
the unique file naming.

<P>
The default location of the final trace file is the working directory at application
start time. If the trace file shall be stored in another place, use
<TT>VT_PFORM_GDIR</TT> as described in Section&nbsp;<A HREF="#sec:env_variables">3.2</A>
to change the location of the trace file.

<P>

<H1><A NAME="SECTION00420000000000000000"></A>
<A NAME="sec:env_variables"></A>
<BR>
Environment Variables
</H1>
The following environment variables can be used to control the measurement
of a VampirTrace instrumented executable:

<P>

<P>
<TABLE CELLPADDING=3>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Variable</SPAN></TH>
<TH ALIGN="LEFT"><SPAN  CLASS="textbf">Purpose</SPAN></TH>
<TH ALIGN="LEFT"><SPAN  CLASS="textbf">Default</SPAN></TH>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_GLOBAL_SETTINGS"></A> </TD>
<TD ALIGN="LEFT">
<BR>
	<SPAN  CLASS="textbf">Global Settings</SPAN> 
	<BR></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_APPPATH"></A><TT>VT_APPPATH</TT></TD>
<TD ALIGN="LEFT">Path to the application executable.
	<BR>
	&#8658; Section&nbsp;<A HREF="#subsec:nmnotes">2.3.2</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_BUFFER_SIZE"></A><TT>VT_BUFFER_SIZE</TT></TD>
<TD ALIGN="LEFT">Size of internal event trace buffer. This is the place where
	event records are stored, before being written to a file.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:trace_file_size">3.3</A></TD>
<TD ALIGN="LEFT">32M</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_CLEAN"></A><TT>VT_CLEAN</TT></TD>
<TD ALIGN="LEFT">Remove temporary trace files?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_COMPRESSION"></A><TT>VT_COMPRESSION</TT></TD>
<TD ALIGN="LEFT">Write compressed trace files?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_FILE_PREFIX"></A><TT>VT_FILE_PREFIX</TT></TD>
<TD ALIGN="LEFT">Prefix used for trace filenames.</TD>
<TD ALIGN="LEFT">&#8658;Sect.<A HREF="#sec:tracefilename">3.1</A></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_FILE_UNIQUE"></A><TT>VT_FILE_UNIQUE</TT></TD>
<TD ALIGN="LEFT">Enable unique trace file naming?
        Set to yes, no, or a numerical ID.
<BR>
	&#8658; Section&nbsp;<A HREF="#sec:tracefilename">3.1</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MAX_FLUSHES"></A><TT>VT_MAX_FLUSHES</TT></TD>
<TD ALIGN="LEFT">Maximum number of buffer flushes.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:trace_file_size">3.3</A></TD>
<TD ALIGN="LEFT">1</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MAX_THREADS"></A><TT>VT_MAX_THREADS</TT></TD>
<TD ALIGN="LEFT">Maximum number of threads per process that VampirTrace reserves resources for.</TD>
<TD ALIGN="LEFT">65536</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MAX_MPI_COMMS"></A><TT>VT_MAX_MPI_COMMS</TT></TD>
<TD ALIGN="LEFT">Maximum number of MPI communicators used in a MPI program.</TD>
<TD ALIGN="LEFT">100</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MAX_MPI_WINS"></A><TT>VT_MAX_MPI_WINS</TT></TD>
<TD ALIGN="LEFT">Maximum number of MPI windows used in a MPI program.</TD>
<TD ALIGN="LEFT">100</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_PFORM_GDIR"></A><TT>VT_PFORM_GDIR</TT></TD>
<TD ALIGN="LEFT">Name of global directory to store final trace file in.</TD>
<TD ALIGN="LEFT"><TT>./</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_PFORM_LDIR"></A><TT>VT_PFORM_LDIR</TT></TD>
<TD ALIGN="LEFT">Name of node-local directory which can be used to store temporary trace files.</TD>
<TD ALIGN="LEFT"><TT>/tmp/</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_UNIFY"></A><TT>VT_UNIFY</TT></TD>
<TD ALIGN="LEFT">Unify local trace files afterwards?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_VERBOSE"></A><TT>VT_VERBOSE</TT></TD>
<TD ALIGN="LEFT">Level of VampirTrace related information messages:
        Quiet (0), Critical (1), Information (2)</TD>
<TD ALIGN="LEFT">1</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_OPTIONAL_FEATURES"></A></TD>
<TD ALIGN="LEFT">
<BR>
	<SPAN  CLASS="textbf">Optional Features</SPAN> 
	<BR></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_CPUIDTRACE"></A><TT>VT_CPUIDTRACE</TT></TD>
<TD ALIGN="LEFT">Enable tracing of core ID of a CPU?
	<BR>
	&#8658; Section <A HREF="#sec:cpu_id_counter">4.4</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_ETIMESYNC"></A><TT>VT_ETIMESYNC</TT></TD>
<TD ALIGN="LEFT">Enable enhanced timer synchronization?
	<BR>
	&#8658; Section <A HREF="#sec:timer_synchronization">3.7</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_ETIMESYNC_INTV"></A><TT>VT_ETIMESYNC_INTV</TT></TD>
<TD ALIGN="LEFT">Interval between two successive synchronization phases in s.</TD>
<TD ALIGN="LEFT">120</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_IOLIB_PATHNAME"></A><TT>VT_IOLIB_PATHNAME</TT></TD>
<TD ALIGN="LEFT">Provides an alternative library to use for LIBC I/O calls.
	&#8658; Section&nbsp;<A HREF="#sec:io_calls">4.8</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_IOTRACE"></A><TT>VT_IOTRACE</TT></TD>
<TD ALIGN="LEFT">Enable tracing of application I/O calls?
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:io_calls">4.8</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_LIBCTRACE"></A><TT>VT_LIBCTRACE</TT></TD>
<TD ALIGN="LEFT">Enable tracing of fork/system/exec calls?
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:execfork">4.9</A> calls</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MEMTRACE"></A><TT>VT_MEMTRACE</TT></TD>
<TD ALIGN="LEFT">Enable memory allocation counter?
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:mem_alloc_counter">4.3</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MODE"></A><TT>VT_MODE</TT></TD>
<TD ALIGN="LEFT">Colon-separated list of VampirTrace modes: Tracing (TRACE), Profiling (STAT).
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:profiling">3.4</A></TD>
<TD ALIGN="LEFT">TRACE</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MPICHECK"></A><TT>VT_MPICHECK</TT></TD>
<TD ALIGN="LEFT">Enable MPI correctness checking via UniMCI?</TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MPICHECK_ERREXIT"></A><TT>VT_MPICHECK_ERREXIT</TT></TD>
<TD ALIGN="LEFT">Force trace write and application exit if an MPI usage error is detected?</TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MPITRACE"></A><TT>VT_MPITRACE</TT></TD>
<TD ALIGN="LEFT">Enable tracing of MPI events?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_OMPTRACE"></A><TT>VT_OMPTRACE</TT></TD>
<TD ALIGN="LEFT">Enable tracing of OpenMP events instrumented by OPARI?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_PTHREAD_REUSE"></A><TT>VT_PTHREAD_REUSE</TT></TD>
<TD ALIGN="LEFT">Reuse IDs of terminated Pthreads?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_STAT_INTV"></A><TT>VT_STAT_INTV</TT></TD>
<TD ALIGN="LEFT">Length of interval in ms for writing the next profiling record</TD>
<TD ALIGN="LEFT">0</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_STAT_PROPS"></A><TT>VT_STAT_PROPS</TT></TD>
<TD ALIGN="LEFT">Colon-separated list of event types that shall be recorded in profiling mode:
        Functions (FUNC), Messages (MSG), Collective Ops. (COLLOP) or all of them
	(ALL)
      	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:profiling">3.4</A></TD>
<TD ALIGN="LEFT">ALL</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_SYNC_FLUSH"></A><TT>VT_SYNC_FLUSH</TT></TD>
<TD ALIGN="LEFT">Enable synchronized buffer flush?
	<BR>
	&#8658; Section <A HREF="#sec:buffer_flush">3.6</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_SYNC_FLUSH_LEVEL"></A><TT>VT_SYNC_FLUSH_LEVEL</TT></TD>
<TD ALIGN="LEFT">Minimum buffer fill level for synchronized buffer flush in percent.</TD>
<TD ALIGN="LEFT">80</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_COUNTERS"></A></TD>
<TD ALIGN="LEFT">
<BR>
	<SPAN  CLASS="textbf">Counters</SPAN> 
	<BR></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_METRICS"></A><TT>VT_METRICS</TT></TD>
<TD ALIGN="LEFT">Specify counter metrics to be recorded with trace events as a
	colon/VT_METRICS_SEP-separated list of names.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:hw_perf_counters">4.1</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_METRICS_SEP"></A><TT>VT_METRICS_SEP</TT></TD>
<TD ALIGN="LEFT">Separator string between counter specifications in VT_METRICS.</TD>
<TD ALIGN="LEFT">:</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_RUSAGE"></A><TT>VT_RUSAGE</TT></TD>
<TD ALIGN="LEFT">Colon-separated list of resource usage counters which shall be recorded.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:rusage_counters">4.2</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_RUSAGE_INTV"></A><TT>VT_RUSAGE_INTV</TT></TD>
<TD ALIGN="LEFT">Sample interval for recording resource usage counters in ms.</TD>
<TD ALIGN="LEFT">100</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_PLUGIN_CNTR_METRICS"></A><TT>VT_PLUGIN_CNTR_METRICS</TT></TD>
<TD ALIGN="LEFT">Colon-separated list of plugin counter metrics which shall be recorded.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:plugin_counter_metrics">4.7</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_FILTERING_GROUPING"></A></TD>
<TD ALIGN="LEFT">
<BR>
	<SPAN  CLASS="textbf">Filtering, Grouping</SPAN> 
	<BR></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_DYN_SHLIBS"></A><TT>VT_DYN_SHLIBS</TT></TD>
<TD ALIGN="LEFT">Colon-separated list of shared libraries for Dyninst instrumentation.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:dyninst">2.6</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_DYN_IGNORE_NODBG"></A><TT>VT_DYN_IGNORE_NODBG</TT></TD>
<TD ALIGN="LEFT">Disable instrumentation of functions which have no debug information?</TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_FILTER_SPEC"></A><TT>VT_FILTER_SPEC</TT></TD>
<TD ALIGN="LEFT">Name of function/region filter file.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:function_filter">5.1</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_GROUPS_SPEC"></A><TT>VT_GROUPS_SPEC</TT></TD>
<TD ALIGN="LEFT">Name of function grouping file.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:function_groups">5.3</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_JAVA_FILTER_SPEC"></A><TT>VT_JAVA_FILTER_SPEC</TT></TD>
<TD ALIGN="LEFT">Name of Java specific filter file.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:java_filter">5.2</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_GROUP_CLASSES"></A><TT>VT_GROUP_CLASSES</TT></TD>
<TD ALIGN="LEFT">Create a group for each Java class automatically?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MAX_STACK_DEPTH"></A><TT>VT_MAX_STACK_DEPTH</TT></TD>
<TD ALIGN="LEFT">Maximum number of stack level to be traced.
	<BR>
	(0 = unlimited)</TD>
<TD ALIGN="LEFT">0</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_SYMBOL_LIST"></A></TD>
<TD ALIGN="LEFT">
<BR>
	<SPAN  CLASS="textbf">Symbol List</SPAN> 
	<BR></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_GNU_NM"></A><TT>VT_GNU_NM</TT></TD>
<TD ALIGN="LEFT">Command to list symbols from object files.
        <BR>
	&#8658; Section&nbsp;<A HREF="#sec:compinst">2.3</A></TD>
<TD ALIGN="LEFT">nm</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_GNU_NMFILE"></A><TT>VT_GNU_NMFILE</TT></TD>
<TD ALIGN="LEFT">Name of file with symbol list information.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:compinst">2.3</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
</TABLE>

<P>
The variables <TT>VT_PFORM_GDIR</TT>, <TT>VT_PFORM_LDIR</TT>, <TT>VT_FILE_PREFIX</TT>
may contain (sub)strings of the form <TT>$XYZ</TT> or <TT>${XYZ}</TT> where
<TT>XYZ</TT> is the name of another environment variable.
Evaluation of the environment variable is done at measurement runtime.

<P>
When you use these environment variables, make sure that they have the same
value for all processes of your application on <SPAN  CLASS="textbf">all</SPAN> nodes of your cluster.
Some cluster environments do not automatically transfer your environment
when executing parts of your job on remote nodes of the cluster, and you
may need to explicitly set and export them in batch job submission scripts.

<P>

<H1><A NAME="SECTION00430000000000000000"></A>
<A NAME="sec:trace_file_size"></A>
<BR>
Influencing Trace Buffer Size
</H1>

<P>
The default values of the environment variables <TT>VT_BUFFER_SIZE</TT> and 
<TT>VT_MAX_FLUSHES</TT> limit the internal buffer of VampirTrace to
32 MB per process and the number of times that the buffer is flushed to 1, 
respectively. Events that are to be recorded after the limit has been reached
are no longer written into the trace file. The environment variables apply 
to every process of a parallel application, meaning that applications with 
<SPAN  CLASS="textit">n</SPAN> processes will typically create trace files <SPAN  CLASS="textit">n</SPAN> times 
the size of a serial application.

<P>
To remove the limit and get a complete trace of an application, set 
<TT>VT_MAX_FLUSHES</TT> to <TT>0</TT>. This causes VampirTrace to always
write the buffer to disk when it is full. To change the size of the
buffer, use the environment variable <TT>VT_BUFFER_SIZE</TT>. The optimal value for
this variable depends on the application which is to be traced. Setting a
small value will increase the memory available to the application, but
will trigger frequent buffer flushes by VampirTrace. These buffer flushes can
significantly change the behavior of the application. On the other hand,
setting a large value, like <TT>2G</TT>, will minimize buffer flushes by
VampirTrace, but decrease the memory available to the application. If not
enough memory is available to hold the VampirTrace buffer and the application
data, parts of the application may be swapped to disk, leading
to a significant change in the behavior of the application.

<P>
Note that you can decrease the size of trace files significantly by
using the runtime function filtering as explained in Section&nbsp;<A HREF="#sec:function_filter">5.1</A>.

<P>

<H1><A NAME="SECTION00440000000000000000"></A>
<A NAME="sec:profiling"></A>
<BR>
Profiling an Application
</H1>
Profiling an application collects aggregated information about certain events during 
a program run, whereas tracing records information about individual events.
Profiling can therefore be used to get a summary of the program activity and to detect events
that are called very often.
The profiling information can also be used to generate filter rules to reduce
the trace file size (&#8658; Section&nbsp;<A HREF="#sec:function_filter">5.1</A>).

<P>
To profile an application set the variable <TT>VT_MODE</TT> to <TT>STAT</TT>.
Setting <TT>VT_MODE</TT> to <TT>STAT:TRACE</TT> tells VampirTrace to perform tracing and profiling at the same time.
By setting the variable <TT>VT_STAT_PROPS</TT> the user can influence whether functions, messages, and/or collective operations
shall be profiled. See Section&nbsp;<A HREF="#sec:env_variables">3.2</A> for information about these environment variables. 

<P>

<H1><A NAME="SECTION00450000000000000000"></A>
<A NAME="sec:unification"></A>
<BR>
Unification of Local Traces
</H1>

<P>
After a run of an instrumented application the traces of the single
processes need to be <SPAN  CLASS="textit">unified</SPAN> in terms of timestamps and event IDs.
In most cases, this happens automatically.
If the environment variable <TT>VT_UNIFY</TT> is set to <TT>no</TT> or under
certain circumstances it is necessary to perform unification of local traces
manually. To do this, use the following command:

<P>
<BR>
<BR>
<code>   % vtunify &lt;prefix&gt;</code>
<BR>
<BR>
<BR>
<P>
If VampirTrace was built with support for OpenMP and/or MPI, it is possible to
speedup the unification of local traces significantly. To distribute the unification
on multible processes the MPI parallel version <TT>vtunify-mpi</TT> can be used as
follow:

<P>
<BR>
<BR>
<code>   % mpirun -np &lt;nranks&gt; vtunify-mpi &lt;prefix&gt;</code>
<BR>
<BR>
<BR>
<P>
Furthermore, both tools <TT>vtunify</TT> and <TT>vtunify-mpi</TT> are capable to
open additional OpenMP threads for unification. The number of threads can be specified
by the <TT>OMP_NUM_THREADS</TT> environment variable.

<P>

<H1><A NAME="SECTION00460000000000000000"></A>
<A NAME="sec:buffer_flush"></A>
<BR>
Synchronized Buffer Flush
</H1>
When tracing an application, VampirTrace temporarily stores the recorded events
in a trace buffer. Typically, if a buffer of a process or thread has reached its
maximum fill level, the buffer has to be flushed and other processes or threads maybe 
have to wait for this process or thread. This will result in an asynchronous
runtime behavior. <BR>
To avoid this problem, VampirTrace provides a buffer flush in a synchronized 
manner. That means, if one buffer has reached its minimum buffer fill level 
<TT>VT_SYNC_FLUSH_LEVEL</TT> (&#8658; Section&nbsp;<A HREF="#sec:env_variables">3.2</A>), all
buffers will be flushed.
This buffer flush is only available at appropriate points in the program flow. 
Currently, VampirTrace makes use of all MPI collective functions associated with 
 <TT>MPI_COMM_WORLD</TT>. Use the environment variable 
<TT>VT_SYNC_FLUSH</TT> to enable synchronized buffer flush.

<P>

<H1><A NAME="SECTION00470000000000000000"></A>
<A NAME="sec:timer_synchronization"></A>
<BR>
Enhanced Timer Synchronization
</H1>

<P>
Especially on cluster environments, where each process has its own local timer,
tracing relies on precisely synchronized timers. Therefore, VampirTrace provides
several mechanisms for timer synchronization. The default synchronization scheme is a
linear synchronization at the very begin and the very end of a trace run with a
master-slave communication pattern. <BR>
However, this way of synchronization can become to imprecise for long trace runs.
Therefore, we recommend the usage of the enhanced timer synchronization scheme of 
VampirTrace. This scheme inserts additional synchronization phases at appropriate
points in the program flow. Currently, VampirTrace makes use of all MPI collective
functions associated with <TT>MPI_COMM_WORLD</TT>.
<BR>
To enable this synchronization scheme, a LAPACK library with C wrapper support has to be 
provided for VampirTrace and the environment variable  
<TT>VT_ETIMESYNC</TT> (&#8658; Section&nbsp;<A HREF="#sec:env_variables">3.2</A>)
has to be set before the tracing.
<BR>
The length of the interval between two successive synchronization phases can be 
adjusted with <TT>VT_ETIMESYNC_INTV</TT>.
<BR>
The following LAPACK libraries provide a C-LAPACK API that can be used by VampirTrace
for the enhanced timer synchronization:

<UL>
<LI>CLAPACK<A NAME="tex2html15"
  HREF="#foot1181"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>
</LI>
<LI>AMD ACML
</LI>
<LI>IBM ESSL
</LI>
<LI>Intel MKL
</LI>
<LI>SUN Performance Library
</LI>
</UL>

<P>

<H4><A NAME="SECTION00470010000000000000">
Note:</A>
</H4>
  Systems equipped with a global timer do not need timer synchronization.

<P>

<H4><A NAME="SECTION00470020000000000000">
Note:</A>
</H4>
  It is recommended to combine enhanced timer synchronization and synchronized buffer flush.

<P>

<H4><A NAME="SECTION00470030000000000000">
Note:</A>
</H4>
  Be aware that the asynchronous behavior of the application will be disturbed since VampirTrace
  makes use of asynchronous MPI collective functions for timer synchronization and synchronized
  buffer flush.
<BR>
Only make use of these approaches, if your application does not rely on an asynchronous behavior!
  Otherwise, keep this fact in mind during the process of performance analysis.

<P>

<H1><A NAME="SECTION00480000000000000000"></A>
<A NAME="sec:vtsetup"></A>
<BR>
Environment Configuration Using VTSetup
</H1>

<P>
In order to ease the process of configuring the runtime environment, the graphical 
tool <TT>vtsetup</TT> has been added to the VampirTrace toolset. With the help
of a graphical user interface, required environment variables can be configured. 
The following option categories can be managed:

<P>

<UL>
<LI><SPAN  CLASS="textbf">General Trace Settings</SPAN>: Configre the name of the executable 
			as well as the trace filename and set the trace buffer size.
</LI>
<LI><SPAN  CLASS="textbf">Optional Trace Features</SPAN>: Activate optional trace features, e.g. I/O 
			tracing and tracing of memory usage.
</LI>
<LI><SPAN  CLASS="textbf">Counters</SPAN>: Activate PAPI counter and resource usage counter.
</LI>
<LI><SPAN  CLASS="textbf">Filtering and Grouping</SPAN>: Guided setup of filters and
			function group definitions.
</LI>
</UL>

<P>
Furthermore, the user is granted more fine-grained control by activating the 
<SPAN  CLASS="textit">Advanced View</SPAN> button. The configuration can be saved to an XML file. 
After successfull configuration, the application can be launched directly or a 
script can be generated for manual execution.

<P>

<H1><A NAME="SECTION00500000000000000000">
Recording Additional Events and Counters</A>
</H1>

<P>

<H1><A NAME="SECTION00510000000000000000"></A>
<A NAME="sec:hw_perf_counters"></A>
<BR>
Hardware Performance Counters
</H1>

<P>
If VampirTrace has been built with hardware counter support (&#8658; 
  Appendix&nbsp;<A HREF="#chap:install">A</A>), it is capable of recording hardware counter
  information as part of the event records. To request the measurement of
  certain counters, the user is required to set the environment variable <TT>VT_METRICS</TT>.
  The variable should contain a colon-separated list of counter names
  or a predefined platform-specific group.

<P>
The user can leave the environment variable unset to indicate that no
  counters are requested. If any of the requested counters are not recognized
  or the full list of counters cannot be recorded due to hardware resource
  limits, program execution will be aborted with an error message.

<P>

<H2><A NAME="SECTION00511000000000000000">
PAPI Hardware Performance Counters</A>
</H2>

<P>
If the PAPI library is used to access hardware performance counters,
  metric names can be any PAPI preset names or PAPI native counter names. 
  For example, set

<P>
<BR>
<BR>
  <code>   VT_METRICS=PAPI_FP_OPS:PAPI_L2_TCM:!CPU_TEMP1</code>
  <BR>
<BR>
<BR>
to record the number of floating point instructions and level 2 cache misses (PAPI preset counters), 
  cpu temperature from the lm_sensors component.
  The leading exclamation mark let CPU_TEMP1 be interpreted as absolute value counter.
  See Section&nbsp;<A HREF="#sec:papi">C.1</A> for a full list of PAPI preset counters.

<P>

<H2><A NAME="SECTION00512000000000000000">
CPC Hardware Performance Counters</A>
</H2>

<P>
On Sun Solaris operating systems VampirTrace can make use of the CPC
  performance counter library to query the processor's hardware performance counters.
  The counters which are actually available on your platform can be queried with
  the tool <TT>vtcpcavail</TT>. The listed names can then be used within
  <TT>VT_METRICS</TT> to tell VampirTrace which counters to record.

<P>

<H2><A NAME="SECTION00513000000000000000">
NEC SX Hardware Performance Counters</A>
</H2>

<P>
On NEC SX machines VampirTrace uses special register calls to query the processor's 
  hardware counters. Use <TT>VT_METRICS</TT> to specify the counters that have to be
  recorded. See Section&nbsp;<A HREF="#sec:necsx_pc">C.3</A> for a full list of NEC SX hardware performance 
  counters.

<P>

<H1><A NAME="SECTION00520000000000000000"></A>
<A NAME="sec:rusage_counters"></A>
<BR>
Resource Usage Counters
</H1>

<P>
The Unix system call <TT>getrusage</TT> provides information about consumed
  resources and operating system events of processes
  such as user/system time, received signals, and context switches.

<P>
If VampirTrace has been built with resource usage support, it is able
  to record this information as performance counters to the trace.
  You can enable tracing of specific resource counters by setting the environment
  variable <TT>VT_RUSAGE</TT> to a colon-separated list of counter names, as
  specified in Section&nbsp;<A HREF="#sec:rusage_list">C.4</A>. For example, set

<P>
<BR>
<BR>
  <code>   VT_RUSAGE=ru_stime:ru_majflt</code>
  <BR>
<BR>
<BR>
to record the system time consumed by each process and the number of page faults.
  Alternatively, one can set this variable to the value <TT>all</TT> to
  enable recording of all 16 resource usage counters.
  Note that not all counters are supported by all Unix operating systems.
  Linux 2.6 kernels, for example, support only resource information for six of them.
  See Section&nbsp;<A HREF="#sec:rusage_list">C.4</A> and the manual page of <TT>getrusage</TT> for details.

<P>
The resource usage counters are not recorded at every event.
  They are only read if 100ms have passed since the last sampling.
  The interval can be changed by setting <TT>VT_RUSAGE_INTV</TT>
  to the number of desired milliseconds.
  Setting <TT>VT_RUSAGE_INTV</TT> to zero leads to sampling resource
  usage counters at every event, which may introduce a large runtime overhead.
  Note that in most cases the operating system does not update the resource usage information 
  at the same high frequency as the hardware performance counters.
  Setting <TT>VT_RUSAGE_INTV</TT> to a value less than 10ms does usually not
  improve the granularity.

<P>
Be aware that, when using the resource usage counters for multi-threaded programs,
  the information displayed is valid for the whole process and not for each single thread.
  
<P>

<H1><A NAME="SECTION00530000000000000000"></A>
<A NAME="sec:mem_alloc_counter"></A>
<BR>
Memory Allocation Counter
</H1>

<P>
The GNU LIBC implementation provides a special hook mechanism that allows
  intercepting all calls to memory allocation and free functions
  (e.g.&nbsp;<TT>malloc</TT>, <TT>realloc</TT>, <TT>free</TT>).
  This is independent from compilation or source code access, but relies on the
  underlying system library.

<P>
If VampirTrace has been built with memory-tracing support (&#8658; 
  Appendix&nbsp;<A HREF="#chap:install">A</A>), VampirTrace is capable of recording memory allocation
  information as part of the event records. To request the measurement of
  the application's allocated memory, the user must set the environment variable
  <TT>VT_MEMTRACE</TT> to <TT>yes</TT>.

<P>

<H4><A NAME="SECTION00530010000000000000">
Note:</A>
</H4>
  This approach to get memory allocation information requires changing internal
  function pointers in a non-thread-safe way, so VampirTrace currently does not support
  memory tracing for thread-able programs, e.g., programs parallelized with OpenMP or Pthreads!

<P>

<H1><A NAME="SECTION00540000000000000000"></A>
<A NAME="sec:cpu_id_counter"></A>
<BR>
CPU ID Counter
</H1>

<P>
The GNU LIBC implementation provides a function to determine the core id of a CPU on which the calling
  thread is running. VampirTrace uses this functionality to record the current core identifier as
  counter. This feature can be activated by setting the environment variable
  <TT>VT_CPUIDTRACE</TT> to <TT>yes</TT>.

<P>

<H4><A NAME="SECTION00540010000000000000">
Note:</A>
</H4>
  To use this feature you need the GNU LIBC implementation at least in version
  2.6.

<P>

<H1><A NAME="SECTION00550000000000000000"></A>
<A NAME="sec:cuda"></A>
<BR>
NVIDIA CUDA Runtime API and Kernels
</H1>
  When tracing CUDA applications, only user events and functions are recorded,
  which are automatically or manually instrumented. CUDA-Runtime API functions
  will not be traced by default.
  To enable tracing of CUDA runtime API functions and asynchronous CUDA tasks 
  (like kernel execution and asynchronous memory copies), build VampirTrace 
  with CUDA support and set the environment variable
  <TT>VT_CUDARTTRACE</TT> to <TT>yes</TT>.
<P></P>

<P>
Every CUDA stream, which is executed on a cuda-capable device and 
  used during program execution, creates an own thread. ``CUDA-Threads'' can 
  contain communication and kernel events and have the following notation:
<P></P>

<P>
<TT>CUDA[device] process:thread</TT>
<P></P>

<P>
To ensure measurement of correct data rates for synchronous CUDA 
  memory copies, VampirTrace inserts a CUDA synchronization before. 
  Otherwise the CUDA memory copy call would do the synchronization and it was 
  not possible to get correct transfer rates.
<P></P>

<P>
As kernel execution and asynchronous memory copies are not executed 
  directly, they will be buffered until a synchronizing CUDA Runtime API 
  function call or the programs exit. The buffer size can be specified in bytes 
  (default: 8192) with the environment variable 
  <TT>VT_CUDATRACE_BUFFER_SIZE</TT>.
<P></P>

<P>
Several new region groups have been introduced:
  <DIV ALIGN="CENTER">

    <TABLE CELLPADDING=3>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">CUDA_KERNEL</SPAN></TH>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=269>CUDA kernels/functions can only appear on 
			      ``CUDA-Threads''</TD>
</TR>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">CUDART_API</SPAN></TH>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=269>CUDA runtime API calls</TD>
</TR>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">VT_CUDA</SPAN></TH>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=269>VampirTrace overhead (write CUDA events, 
			      check current device, etc.)</TD>
</TR>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">CUDA_SYNC</SPAN></TH>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=269>CUDA synchronization</TD>
</TR>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">CUDA_IDLE</SPAN></TH>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=269>GPU idle time - the CUDA device does not run any 
			      kernel currently (can only appear in one stream of 
                              the device)</TD>
</TR>
</TABLE>
</DIV>

<P>
Additional feature switches (environment variables):
  <DL>
<DT></DT>
<DD><TT>VT_CUDATRACE_KERNEL</TT> (default: <TT>yes</TT>)
<BR>
Tracing of CUDA kernels is enabled/disabled.
    
</DD>
<DT></DT>
<DD><TT>VT_CUDATRACE_MEMCPYASYNC</TT> (default: <TT>yes</TT>)
<BR>
Tracing of asynchronous CUDA memory copies is enabled/disabled.
    
</DD>
<DT></DT>
<DD><TT>VT_CUDATRACE_IDLE</TT> (default: <TT>no</TT>)
<BR>
Show the GPU idle time on a CUDA stream, if set to <TT>yes</TT>.
    
</DD>
<DT></DT>
<DD><TT>VT_CUDATRACE_GPUMEMUSAGE</TT> (default: <TT>no</TT>)
<BR>
Visualize GPU memory usage as counter ``gpu_mem_usage``, if set to <TT>yes</TT>.
    
</DD>
<DT></DT>
<DD><TT>VT_CUDATRACE_SYNC</TT> (default: <TT>yes</TT> or <TT>3</TT>)
<BR>
Controls how VampirTrace handles synchronizing CUDA API calls, especially 
      <SPAN  CLASS="textit">cudaMemcpy</SPAN> and <SPAN  CLASS="textit">cudaThreadSynchronize</SPAN>.
      At level 0 only the CUDA calls will be executed, messages will be 
      displayed from the beginning to the end of the <SPAN  CLASS="textit">cudaMemcpy</SPAN>, regardless how 
      long the <SPAN  CLASS="textit">cudaMemcpy</SPAN> call has to wait for a kernel until the actual 
      data transfer starts. 
      At level 1 the <SPAN  CLASS="textit">cudaMemcpy</SPAN> will be split into an additional synchronization 
      and the actual data transfer in order to monitor the data transfer correctly. 
      The additional synchronization does not affect the program execution 
      significantly and will not be shown in the trace.
      At level 2 the additional synchronization will be exposed to the user. 
      This allows a better view on the application execution, showing how much 
      time is actually spent waiting for a kernel to complete during synchronization.
      Level 3 will further use the synchronization to flush the internal task 
      buffer and perform a timer synchronization between GPU und and host. This 
      introduces a minimal overhead but increases timer precision and prevents 
      flushes elsewhere in the trace.
    
</DD>
<DT></DT>
<DD><TT>VT_CUPTI_METRICS</TT> (default: <TT>""</TT>)
<BR>
Capture CUDA CUPTI counters. Metrics are separated by default with '':`` 
      or user specified by <TT>VT_METRICS_SEP</TT>.
<BR>
Example: <TT>VT_CUPTI_METRICS=local_store:local_load</TT>
 
</DD>
</DL>

<P>
Until CUDA Runtime Version 4.0 and CUDA Driver for Linux 270.27 the usage of 
  CUDA events between asynchronous tasks serializes their on-device execution. 
  This seems to be a bug, which has already been reported to NVIDIA. 
  As VampirTrace uses CUDA events for time measurement and asynchronous tasks 
  may overlap (depends on the CUDA device capability), there might be a sensible 
  impact on the program flow. 
  The current workaround is to disable tracing of kernels and/or asynchronous 
  memory copies via the given environment variables.

<P>

<H3><A NAME="SECTION00550100000000000000">
Available CUDA Counter</A>
</H3>
  If <TT>VT_CUDATRACE_GPUMEMUSAGE</TT> is enabled, 
  <SPAN  CLASS="textit">cudaMalloc</SPAN> and <SPAN  CLASS="textit">cudaFree</SPAN> functions will be tracked to write 
  the GPU memory usage counter <TT>gpu_mem_usage</TT>. 

<P>
There are three counters, which provide some information about the kernel 
  grid, block and thread compostion (<TT>blocks_per_grid</TT>, 
  <TT>threads_per_block</TT>, <TT>threads_per_kernel</TT>).

<P>

<H3><A NAME="SECTION00550200000000000000">
Compile and Link CUDA applications</A>
</H3>
  Use the VampirTrace compiler wrapper <TT>vtnvcc</TT> instead of <TT>nvcc</TT> 
  to compile the CUDA application, which does automatic source code instrumenation.
<P></P>

<BR>
<P>
<SMALL CLASS="SMALL"><SPAN  CLASS="textbf">GCC4.3 and OpenMP:</SPAN></SMALL>
<BR>
Use the flags <TT>-vt:opari -nodecl -Xcompiler=-fopenmp</TT> with <TT>vtnvcc</TT> 
  to compile the OpenMP CUDA application.
<P></P>

<BR>
<P>
<SMALL CLASS="SMALL"><SPAN  CLASS="textbf">CUDA 3.1:</SPAN></SMALL>
<BR>
The CUDA runtime library 3.1 creates a conflict with <TT>zlib</TT>. 
  A workaround is to replace all 
  <TT>gcc/g++</TT> calls with the VampirTrace compiler wrappers 
  (<TT>vtcc/vtc++</TT>) and pass the following additional flags to 
  <TT>nvcc</TT> for compilation of the kernels:
  <PRE>
  -I$VT_INSTALL_PATH/include/vampirtrace
  -L$VT_INSTALL_PATH/lib 
  -Xcompiler=-g,-finstrument-functions,-pthread
  -lvt -lotf -lcudart -lz -ldl -lm
</PRE>
  <SMALL CLASS="FOOTNOTESIZE"><TT>$VT_INSTALL_PATH</TT> is the path to the VampirTrace installation 
  directory. It is not necessary to specify the VampirTrace include and library 
  path, if it is installed in the default directory.
<BR>  </SMALL>

<P>
This uses automatic compiler instrumentation (<TT>-finstrument-functions</TT>) 
  and the standard VampirTrace library. Replace the <TT>-lvt</TT> with 
  <TT>-lvt-mt</TT> for multithreaded, <TT>-lvt-mpi</TT> for MPI and 
  <TT>-lvt-hyb</TT> for multithreaded MPI applications. In this case the CUDA 
  runtime library is linked before the <TT>zlib</TT>.

<P>
If the application is linked with <TT>gcc/g++</TT>, the linking command has to ensure, 
  that the respective VampirTrace library is linked before the CUDA runtime 
  library <TT>libcudart.so</TT> (check e.g. with ``ldd <SPAN  CLASS="textit">executable</SPAN>''). 
  Using the VampirTrace compiler wrappers (<TT>vtcc/vtc++</TT>) for linking is 
  the easiest way to ensure correct linking of the VampirTrace library.

<P>
With the library tracing mechanism described in section <A HREF="#sec:3rd-party">2.9</A>, 
  it is possible to trace CUDA applications without recompiling or relinking. 
  There are only events written for Runtime API calls, kernels and communication 
  between host and device.

<P>

<H3><A NAME="SECTION00550300000000000000">
Tracing the NVIDIA CUDA SDK 3.x and 4.0</A>
</H3>
  To get some example traces, replace the compiler commands in the common 
  Makefile include file (<TT>common/common.mk</TT>) with the corresponding 
  VampirTrace compiler wrappers (&#8658;<A HREF="#sec:compiler_wrappers">2.1</A>) for 
  automatic instrumentation:
  <PRE>
  # Compilers
  NVCC := vtnvcc
  CXX  := vtc++
  CC   := vtcc
  LINK := vtc++ #-vt:mt
</PRE>
  Use the compiler switches for MPI, multithreaded 
  and hybrid programs, if necessary (e.g. the CUDA SDK example 
  <TT>simpleMultiGPU</TT> is a multithreaded program, which needs to be linked 
  with a multithreaded VampirTrace library - uncomment the compiler switch 
  in the linker command to use the multithreaded VampirTrace library). 
  
<P><P>
<BR>

<BR>
<P>

<H3><A NAME="SECTION00550400000000000000">
Multithreaded CUDA applications</A>
</H3>
  If threads are used to invoke asynchronous CUDA tasks, make sure to call a 
  synchronizing CUDA function to get the tasks flushed before the thread exits. 
  Otherwise tasks may not be flushed and will be missing in the trace file.
<P>
<BR>

<BR>
<P>

<H3><A NAME="SECTION00550500000000000000">
Mixed Use of CUDA runtime and driver API</A>
</H3>
  As CUDA runtime API may implicitly create and destroy CUDA contexts, there 
  might occur problems during CUDA event flushing. To workaround such an issue 
  use only one API for interaction (memory copies, kernel execution) with the 
  CUDA device. If you have to mix both APIs, make a clean exit for the API, 
  which used the asynchronous tasks, before the other API closes its thread or 
  context - cudaThreadExit() for runtime API and cuCtxDestroy() for driver API. 
  Otherwise not yet flushed, asynchronous tasks will be missing in the final trace.

<P>

<H3><A NAME="SECTION00550600000000000000">
CUDA Performance Counters - CUPTI Events</A>
</H3>
  To capture performance counters in CUDA applications, CUPTI metrics can be 
  specified with the environment variable <TT>VT_CUPTI_METRICS</TT>. Metrics 
  are separated by default with '':`` or user specified by 
  <TT>VT_METRICS_SEP</TT>. The <SPAN  CLASS="textit">CUPTI User's Guide</SPAN> provides 
  information about the available counters.
  Due to the use of asynchronous CUDA events in a GPU stream, VampirTrace 
  currently writes CUPTI counters directly on the process stream, which created 
  the GPU stream. Future implementations will write these counter information 
  on the GPU stream, where the corresponding CUDA kernel runs on.
  
<P><P>
<BR>

<BR>
<P>
<SPAN  CLASS="textbf">Note:</SPAN>
<BR>
For 64-bit systems VampirTrace has to be configured with the 64-bit 
  version of cuda runtime library. If the link test fails, use the 
  following configure option (&#8658;<A HREF="#sec:configure">A.2</A>):
  <PRE>
  --with-cudart-lib-dir=$CUDA_INSTALL_PATH/lib64
</PRE>

<P>
VampirTrace CUDA has been succesfully tested with the CUDA runtime 
  version 3.x and 4.0. 

<P>

<H1><A NAME="SECTION00560000000000000000"></A>
<A NAME="sec:pthread_calls"></A>
<BR>
Pthread API Calls
</H1>
  When tracing applications with Pthreads, only user events and 
  functions are recorded which are automatically or manually instrumented. 
  Pthread API functions will not be traced by default.
<BR>
To enable tracing of all C-Pthread API functions include the header
  <TT>vt_user.h</TT> and compile the instrumented sources with 
  <TT>-DVTRACE_PTHREAD</TT>. 
<PRE>
C/C++:
           #include "vt_user.h"
</PRE>
<BR>
<BR>
<code>   % vtcc </code><TT><SPAN  CLASS="textbf">-DVTRACE_PTHREAD</SPAN></TT><code> hello.c -o hello</code>
<BR>
<BR>
<BR>
<P>

<H4><A NAME="SECTION00560010000000000000">
Note:</A>
</H4> Currently, Pthread instrumentation is only available for C/C++.

<P>

<H1><A NAME="SECTION00570000000000000000"></A>
<A NAME="sec:plugin_counter_metrics"></A>
<BR>
Plugin Counter Metrics
</H1>
  Plugin Counter add additional metrics to VampirTrace. They highly depend on
  the plugins, which are installed on your system. Every plugin should provide a
  README, which should be checked for available metrics.
  Once you have downloaded and compiled a plugin, copy the resulting library to
  a folder, which is part of your <TT>LD_LIBRARY_PATH</TT>.
  To enable the tracing of a specific metric, you should set the environment
  variable <TT>VT_PLUGIN_CNTR_METRICS</TT>. It is set in the following manner
<PRE>
export VT_PLUGIN_CNTR_METRICS=&lt;library_name&gt;_&lt;event_name&gt;
</PRE>
  If you have for example a library named <TT>libKswEvents.so</TT> with the
  event <TT>page_faults</TT>, the you can set it with
<PRE>
export VT_PLUGIN_CNTR_METRICS=KswEvents_page_faults
</PRE>
 Visit <TT><A NAME="tex2html17"
  HREF="http://www.tu-dresden.de/zih/vampirtrace/plugin_counter">http://www.tu-dresden.de/zih/vampirtrace/plugin_counter</A></TT> for
 documentation and examples.

<H4><A NAME="SECTION00570010000000000000">
Note:</A>
</H4> Multiple events can be concatenated by using colons.

<P>

<H1><A NAME="SECTION00580000000000000000"></A>
<A NAME="sec:io_calls"></A>
<BR>
I/O Calls
</H1>

<P>
Calls to functions which reside in external libraries can be intercepted by
  implementing identical functions and linking them before the external library.
  Such ``wrapper functions'' can record the parameters and return values of the
  library functions.

<P>
If VampirTrace has been built with I/O tracing support, it uses this technique
  for recording calls to I/O functions of the standard C library, which are
  executed by the application. The following functions
  are intercepted by VampirTrace:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>close</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>creat</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>creat64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>dup</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>dup2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fclose</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fcntl</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fdopen</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fgetc</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fgets</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>flockfile</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fopen</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fopen64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fprintf</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fputc</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fputs</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fread</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fscanf</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fseek</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fseeko</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fseeko64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fsetpos</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fsetpos64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>ftrylockfile</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>funlockfile</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fwrite</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>getc</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>gets</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>lockf</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>lseek</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>lseek64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>open</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>open64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>pread</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>pread64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>putc</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>puts</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>pwrite</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>pwrite64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>read</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>readv</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>rewind</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>unlink</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>write</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>writev</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110>&nbsp;</TD>
</TR>
</TABLE>

<P>
The gathered information will be saved
  as I/O event records in the trace file. This feature has to be activated for
  each tracing run by setting the environment variable <TT>VT_IOTRACE</TT> to
  <TT>yes</TT>.

<P>
This works for both dynamically and statically linked executables.
  Note that when linking statically, a warning like the following may be issued: Using 'dlopen' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking.
  This is ok as long as the mentioned libraries are available for running the application.

<P>
If you'd like to experiment with some other I/O library, set the environment variable <TT>VT_IOLIB_PATHNAME</TT> to the alternative one.
  Beware that this library must provide all I/O functions mentioned above otherwise VampirTrace will abort.

<P>

<H1><A NAME="SECTION00590000000000000000"></A>
<A NAME="sec:execfork"></A>
<BR>
fork/system/exec Calls
</H1>

<P>
If VampirTrace has been built with LIBC trace support (&#8658; Appendix&nbsp;<A HREF="#chap:install">A</A>),
  it is capable of tracing programs which call functions from the LIBC <TT>exec</TT> family
  (<TT>execl</TT>, <TT>execlp</TT>, <TT>execle</TT>, <TT>execv</TT>, <TT>execvp</TT>, <TT>execve</TT>),
  <TT>system</TT>, and <TT>fork</TT>.
  VampirTrace records the call of the LIBC function to the trace.
  This feature works for sequential (i.e. no MPI or threaded parallelization) programs only.
  It works for both dynamically and statically linked executables.
  Note that when linking statically, a warning like the following may be issued: Using 'dlopen' in statically linked applications requires at
  runtime the shared libraries from the glibc version used for linking.
  This is ok as long as the mentioned libraries are available for running the application.

<P>
When VampirTrace detects a call of an <TT>exec</TT> function,
  the current trace file is closed before executing the new program.
  If the executed program is also instrumented with VampirTrace, it will create a different trace file.
  Note that VampirTrace aborts if the exec function returns unsuccessfully.

<P>
Calling <TT>fork</TT> in an instrumented program creates an additional process in the same trace file.

<P>

<H1><A NAME="SECTION005100000000000000000"></A>
<A NAME="sec:unimci"></A>
<BR>
MPI Correctness Checking Using UniMCI
</H1>

<P>
VampirTrace supports the recording of MPI correctness events, e.g., usage of invalid MPI requests. This is implemented by using the Universal MPI
  Correctness Interface (UniMCI), which provides an interface between tools like VampirTrace and existing runtime MPI correctness checking tools.
  Correctness events are stored as markers in the trace file and are visualized by Vampir.

<P>
If VampirTrace is built with UniMCI support, the user only has to enable MPI correctness checking. This is done by merely setting the environment
  variable <TT>VT_MPICHECK</TT> to <TT>yes</TT>. Further, if your application crashes due to an MPI error you should set
  <TT>VT_MPICHECK_ERREXIT</TT> to <TT>yes</TT>. This environmental variable forces VampirTrace to write its trace to disk and exit afterwards. As
  a result, the trace with the detected error is stored before the application might crash.

<P>
To install VampirTrace with correctness checking support it is necessary to have UniMCI installed on your system. UniMCI in turn requires you to
  have a supported MPI correctness checking tool installed, currently only the tool Marmot is known to have UniMCI support. So all in all you should
  use the following order to install with correctness checking support:
  
<OL>
<LI>Marmot
<BR>    (see <TT><A NAME="tex2html18"
  HREF="http://www.hlrs.de/organization/av/amt/research/marmot">http://www.hlrs.de/organization/av/amt/research/marmot</A></TT>)
</LI>
<LI>UniMCI
<BR>    (see <TT><A NAME="tex2html19"
  HREF="http://www.tu-dresden.de/zih/unimci">http://www.tu-dresden.de/zih/unimci</A></TT>)
</LI>
<LI>VampirTrace
<BR>    (see <TT><A NAME="tex2html20"
  HREF="http://www.tu-dresden.de/zih/vampirtrace">http://www.tu-dresden.de/zih/vampirtrace</A></TT>)
  
</LI>
</OL>

<P>
Information on how to install Marmot and UniMCI is given in their respective manuals. VampirTrace will automatically detect an UniMCI installation
  if the <TT>unimci-config</TT> tool is in path.

<P>

<H1><A NAME="SECTION005110000000000000000"></A>
<A NAME="sec:userdefinedcounters"></A>
<BR>
User-defined Counters
</H1>

<P>
In addition to the manual instrumentation (&#8658; Section&nbsp;<A HREF="#sec:maninst">2.4</A>), the VampirTrace API
  provides instrumentation calls which allow recording of 
  program variable values (e.g. iteration counts, calculation results, ...) or any other 
  numerical quantity.
  A user-defined counter is identified by its name, the counter group it belongs to,
  the type of its value (integer or floating-point) and the unit that the value is 
  quoted (e.g.&nbsp;``GFlop/sec'').

<P>
The <TT>VT_COUNT_GROUP_DEF</TT> and <TT>VT_COUNT_DEF</TT> instrumentation
  calls can be used to define counter groups and counters:

<P>
<PRE>
Fortran:
           #include "vt_user.inc"
           integer :: id, gid
           VT_COUNT_GROUP_DEF('name', gid)
           VT_COUNT_DEF('name', 'unit', type, gid, id)
</PRE> 

<P>
<PRE>
C/C++:
           #include "vt_user.h"
           unsigned int id, gid;
           gid = VT_COUNT_GROUP_DEF("name");
           id = VT_COUNT_DEF("name", "unit", type, gid);
</PRE>

<P>
The definition of a counter group is optional. If no special counter group is desired,
  the default group ``User'' can be used.
  In this case, set the parameter <TT>gid</TT> of <TT>VT_COUNT_DEF()</TT> to
  <TT>VT_COUNT_DEFGROUP</TT>.

<P>
The third parameter <TT>type</TT> of <TT>VT_COUNT_DEF</TT> specifies the data
  type of the counter value. To record a value for any of the defined counters the 
  corresponding instrumentation call <TT>VT_COUNT_*_VAL</TT> must be invoked.

<P>

<P>
<TABLE CELLPADDING=3>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Fortran:</SPAN></TH>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Type</SPAN></TH>
<TD ALIGN="LEFT"><SPAN  CLASS="textbf">Count call</SPAN></TD>
<TD ALIGN="LEFT"><SPAN  CLASS="textbf">Data type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_INTEGER</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_INTEGER_VAL</TT></TD>
<TD ALIGN="LEFT">integer (4 byte)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_INTEGER8</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_INTEGER8_VAL</TT></TD>
<TD ALIGN="LEFT">integer (8 byte)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_REAL</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_REAL_VAL</TT></TD>
<TD ALIGN="LEFT">real</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_DOUBLE</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_DOUBLE_VAL</TT></TD>
<TD ALIGN="LEFT">double precision</TD>
</TR>
</TABLE>

<P>
<TABLE CELLPADDING=3>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">C/C++:</SPAN></TH>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Type</SPAN></TH>
<TD ALIGN="LEFT"><SPAN  CLASS="textbf">Count call</SPAN></TD>
<TD ALIGN="LEFT"><SPAN  CLASS="textbf">Data type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_SIGNED</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_SIGNED_VAL</TT></TD>
<TD ALIGN="LEFT">signed int (max. 64-bit)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_UNSIGNED</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_UNSIGNED_VAL</TT></TD>
<TD ALIGN="LEFT">unsigned int (max. 64-bit)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_FLOAT</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_FLOAT_VAL</TT></TD>
<TD ALIGN="LEFT">float</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_DOUBLE</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_DOUBLE_VAL</TT></TD>
<TD ALIGN="LEFT">double</TD>
</TR>
</TABLE>

<P>
The following example records the loop index <TT>i</TT>:

<P>
<PRE>
Fortran:

  #include "vt_user.inc"

  program main
  integer :: i, cid, cgid

  VT_COUNT_GROUP_DEF('loopindex', cgid)
  VT_COUNT_DEF('i', '#', VT_COUNT_TYPE_INTEGER, cgid, cid)

  do i=1,100
    VT_COUNT_INTEGER_VAL(cid, i)
  end do

  end program main
</PRE> 

<P>
<PRE>
C/C++:

  #include "vt_user.h"

  int main() {
    unsigned int i, cid, cgid;

    cgid = VT_COUNT_GROUP_DEF('loopindex');
    cid = VT_COUNT_DEF("i", "#", VT_COUNT_TYPE_UNSIGNED,
                       cgid);

    for( i = 1; i &lt;= 100; i++ ) {
      VT_COUNT_UNSIGNED_VAL(cid, i);
    }

    return 0;
  }
</PRE>

<P>
For all three languages the instrumented sources have to be compiled 
  with <TT>-DVTRACE</TT>. Otherwise the <TT>VT_*</TT> calls are ignored.

<P>
Optionally, if the sources contain further VampirTrace API calls and only the
  calls for user-defined counters shall be disabled, then the sources have to be
  compiled with <TT>-DVTRACE_NO_COUNT</TT> in addition to <TT>-DVTRACE</TT>.

<P>

<H1><A NAME="SECTION005120000000000000000"></A>
<A NAME="sec:userdefinedmarkers"></A>
<BR>
User-defined Markers
</H1>

<P>
In addition to the manual instrumentation (&#8658; Section&nbsp;<A HREF="#sec:maninst">2.4</A>), the VampirTrace API
  provides instrumentation calls which allow recording of special user information, which 
  can be used to better identify parts of interest.
  A user-defined marker is identified by its name and type.

<P>
<PRE>
Fortran:
           #include "vt_user.inc"
           integer :: mid
           VT_MARKER_DEF('name', type, mid)
           VT_MARKER(mid, 'text')

C/C++:
           #include "vt_user.h"
           unsigned int mid;
           mid = VT_MARKER_DEF("name",type);
           VT_MARKER(mid, "text");

Types for Fortran/C/C++:
           VT_MARKER_TYPE_ERROR
           VT_MARKER_TYPE_WARNING
           VT_MARKER_TYPE_HINT
</PRE>

<P>
For all three languages the instrumented sources have to be compiled 
  with <TT>-DVTRACE</TT>. Otherwise the <TT>VT_*</TT> calls are ignored.

<P>
Optionally, if the sources contain further VampirTrace API calls and only the
  calls for user-defined markers shall be disabled, then the sources have to be
  compiled with <TT>-DVTRACE_NO_MARKER</TT> in addition to <TT>-DVTRACE</TT>.

<P>

<H1><A NAME="SECTION005130000000000000000"></A>
<A NAME="sec:userdefinedcomm"></A>
<BR>
User-defined Communcation
</H1>
In addition to the manual instrumentation (&#8658; Section&nbsp;<A HREF="#sec:maninst">2.4</A>), 
the VampirTrace API provides instrumentation calls which allow recording of 
special user information, which can be used to better identify parts of interest.
A user-defined communication operation is defined by a communicator and a tag.
The default communicator is <TT>VT_COMM_WORLD</TT>. 
Additionally, a user-defined communicator can be created using
<TT>VT_COMM_DEF</TT>:

<P>
<PRE>
Fortran:
         #include "vt_user.inc"
         integer :: cid
         VT_COMM_DEF('name', cid)
			
C/C++:
         #include "vt_user.h"
         unsigned cid;
         cid = VT_COMM_DEF("name", cid);
</PRE>

<P>
Using <TT>VT_SEND</TT> and <TT>VT_RECV</TT> the user
can insert send and receive events into the trace:

<P>
<PRE>
C/C++:
         int rank, size;
         MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
         MPI_Comm_size(MPI_COMM_WORLD, &amp;size);

         if( rank == 0 )
         {
             for ( int i = 1; i &lt; size; i++ )
             {
                 VT_SEND(VT_COMM_WORLD,i,100);
             }  
         }else
         {
             VT_RECV(VT_COMM_WORLD,rank,100);
         }
</PRE>

<P>
The calls are similar for Fortran. 

<P>
As can be seen, the arguments to <TT>VT_SEND</TT> and <TT>VT_RECV</TT> 
are a communicator, a tag and the size of the message. The tag is required in order to
identify both ends of a user-defined communication. Therefore it has to be 
globally unique for a given communicator and cannot be reused within a single communicator.
Messages with duplicated tags will not be visible in the final trace.

<P>
For all three languages the instrumented sources have to be compiled 
with <TT>-DVTRACE</TT>. Otherwise the <TT>VT_*</TT> calls are ignored. Optionally, if the sources contain further VampirTrace API calls and only the
calls for user-defined markers shall be disabled, then the sources have to be
compiled with <TT>-DVTRACE_NO_MSG</TT> in addition to <TT>-DVTRACE</TT>.

<P>

<H1><A NAME="SECTION00600000000000000000"></A>
<A NAME="filtering_and_grouping"></A>
<BR>
Filtering &amp; Grouping
</H1>

<P>

<H1><A NAME="SECTION00610000000000000000"></A>
<A NAME="sec:function_filter"></A>
<BR>
Function Filtering
</H1>

<P>
By default, all calls of instrumented functions will be traced, so that the
  resulting trace files can easily become very large. In order to decrease the
  size of a trace, VampirTrace allows the specification of filter directives
  before running an instrumented application.
  The user can decide on how often an instrumented function/region shall be
  recorded to a trace file.
  To use a filter, the environment variable <TT>VT_FILTER_SPEC</TT> needs to be 
  defined. It should contain the path and name of a file with filter directives.

<P>
Here is an example of a file containing filter directives:

<P>
<PRE>
  #    VampirTrace region filter specification
  #   
  #    call limit definitions and region assignments
  #   
  #    syntax: &lt;regions&gt; -- &lt;limit&gt;
  #   
  #      regions    semicolon-separated list of regions
  #                 (can be wildcards)
  #      limit      assigned call limit
  #                  0 = region(s) denied
  #                 -1 = unlimited
  #   
  add;sub;mul;div -- 1000
  * -- 3000000
</PRE> 

<P>
These region filter directives cause that the functions <TT>add</TT>, 
<TT>sub</TT>, <TT>mul</TT> and <TT>div</TT> be recorded at most 1000 times. 
The remaining functions <TT>*</TT> will be recorded at most 3000000 times.

<P>
Besides creating filter files manually, you can also use the <TT>vtfilter</TT>
tool to generate them automatically. This tool reads a provided trace
and decides whether a function should be filtered or not, based on the evaluation of
certain parameters. For more information see Section&nbsp;<A HREF="#sec:VTFILTER">B.4</A>.

<P>

<H2><A NAME="SECTION00611000000000000000">
Rank Specific Filtering</A>
</H2>

<P>
An experimental extension allows rank specific filtering. Use <TT>@</TT> clauses to
restrict all following filters to the given ranks. The rank selection must be given
as a list of <TT>&lt;from&gt; - &lt;to&gt;</TT> pairs or single values. 
Note that all rank specific rules are only effective after MPI_Init because the ranks
is unknown before. 
The optional argument <TT>- OFF</TT> disables the given ranks completely, regardless of following filter rules. 

<P>
<PRE>
  @ 35 - 42 -- OFF
  @ 4 - 10, 20 - 29, 34
  foo;bar -- 2000
  * -- 0
</PRE>

<P>
The example defines two limits for the ranks 4 - 10, 20 - 29, and 34. The first line disables the ranks 35 - 42 completely.

<P>

<H4><A NAME="SECTION00611010000000000000">
Attention:</A>
</H4>
The rank specific rules are activated later than usual at MPI_Init, because
the ranks are not available earlier. The special MPI routines MPI_Init, MPI_Init_thread,
and MPI_Initialized cannot be filtered in this way.

<P>

<H1><A NAME="SECTION00620000000000000000"></A>
<A NAME="sec:java_filter"></A>
<BR>
Java Specific Filtering
</H1>

<P>
For Java tracing there are additional possibilities of filtering. Firstly,
  there is a default filter applied. The rules can be found in the filter file
  <TT>&lt;vt-install&gt;/etc/</TT> <TT>vt-java-default-filter.spec</TT>.
  Secondly, user-defined filters can be applied additionally by setting
  <TT>VT_JAVA_FILTER_SPEC</TT> to a file containing the rules.

<P>
The syntax of the filter rules is as follows:

<P>
<PRE>
 &lt;method|thread&gt; &lt;include|exclude&gt; &lt;filter string[;fs]...&gt;
</PRE>

<P>
Filtering can be done on thread names and method names, defined by the first
  parameter. The second parameter determines whether the matching item shall be
  included for tracing or excluded from it. Multiple filter strings on a line
  have to be separated by <TT>;</TT> and may contain occurences of <TT>*</TT>
  for wildcard matching.

<P>
The user-supplied filter rules will be applied before the default filter and
  the first match counts so it is possible to include items that would be
  excluded by the default filter otherwise.

<P>

<H1><A NAME="SECTION00630000000000000000"></A>
<A NAME="sec:function_groups"></A>
<BR>
Function Grouping
</H1>

<P>
VampirTrace allows assigning functions/regions to a group. 
  Groups can, for instance, be highlighted by different colors in Vampir displays.
  The following standard groups are created by VampirTrace:

<P>
<TABLE CELLPADDING=3>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Group name</SPAN></TH>
<TH ALIGN="LEFT"><SPAN  CLASS="textbf">Contained functions/regions</SPAN></TH>
</TR>
<TR><TD ALIGN="LEFT"><TT>MPI</TT></TD>
<TD ALIGN="LEFT">MPI functions</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>OMP</TT></TD>
<TD ALIGN="LEFT">OpenMP API function calls</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>OMP_SYNC</TT></TD>
<TD ALIGN="LEFT">OpenMP barriers</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>OMP_PREG</TT></TD>
<TD ALIGN="LEFT">OpenMP parallel regions</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Pthreads</TT></TD>
<TD ALIGN="LEFT">Pthread API function calls</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>MEM</TT></TD>
<TD ALIGN="LEFT">Memory allocation functions (&#8658; Section&nbsp;<A HREF="#sec:mem_alloc_counter">4.3</A>)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>I/O</TT></TD>
<TD ALIGN="LEFT">I/O functions (&#8658; Section&nbsp;<A HREF="#sec:io_calls">4.8</A>)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>LIBC</TT></TD>
<TD ALIGN="LEFT">LIBC fork/system/exec functions (&#8658; Section&nbsp;<A HREF="#sec:execfork">4.9</A>)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Application</TT></TD>
<TD ALIGN="LEFT">remaining instrumented functions and source code regions</TD>
</TR>
</TABLE>

<P>
Additionally, you can create your own groups, e.g.,&nbsp;to better distinguish
  different phases of an application.
  To use function/region grouping set the environment variable
  <TT>VT_GROUPS_SPEC</TT> to the path of a file which contains the group
  assignments. 
  Below, there is an example of how to use group assignments:

<P>
<PRE>
  #    VampirTrace region groups specification
  #
  #    group definitions and region assignments
  #
  #    syntax: &lt;group&gt;=&lt;regions&gt;
  #
  #      group      group name 
  #      regions    semicolon-separated list of regions
  #                 (can be wildcards)
  #
  CALC=add;sub;mul;div
  USER=app_*
</PRE> 

<P>
These group assignments associate the functions <TT>add</TT>, <TT>sub</TT>, 
<TT>mul</TT> and <TT>div</TT> with group ``CALC'', and all functions 
with the prefix <TT>app_</TT> are associated with group ``USER''.

<P>

<H1><A NAME="SECTION00700000000000000000">
Counter Specifications</A>
</H1>

<P>

<H1><A NAME="SECTION00710000000000000000"></A>
<A NAME="sec:papi"></A>
<BR>
PAPI
</H1>

<P>
Available counter names can be queried with the PAPI commands 
<TT>papi_avail</TT> and <TT>papi_native_avail</TT>.
Depending on the hardware there are limitations in the combination 
of different counters. To check whether your choice works properly, 
use the command <TT>papi_event_chooser</TT>.

<P>
<PRE>
PAPI_L[1|2|3]_[D|I|T]C[M|H|A|R|W]    
              Level 1/2/3 data/instruction/total cache 
              misses/hits/accesses/reads/writes

PAPI_L[1|2|3]_[LD|ST]M    
              Level 1/2/3 load/store misses                       

PAPI_CA_SNP   Requests for a snoop                                
PAPI_CA_SHR   Requests for exclusive access to shared cache line  
PAPI_CA_CLN   Requests for exclusive access to clean cache line   
PAPI_CA_INV   Requests for cache line invalidation                
PAPI_CA_ITV   Requests for cache line intervention                

PAPI_BRU_IDL  Cycles branch units are idle                        
PAPI_FXU_IDL  Cycles integer units are idle                       
PAPI_FPU_IDL  Cycles floating point units are idle                
PAPI_LSU_IDL  Cycles load/store units are idle                    

PAPI_TLB_DM   Data translation lookaside buffer misses            
PAPI_TLB_IM   Instruction translation lookaside buffer misses     
PAPI_TLB_TL   Total translation lookaside buffer misses           

PAPI_BTAC_M   Branch target address cache misses                  
PAPI_PRF_DM   Data prefetch cache misses                          
PAPI_TLB_SD   Translation lookaside buffer shootdowns             

PAPI_CSR_FAL  Failed store conditional instructions               
PAPI_CSR_SUC  Successful store conditional instructions           
PAPI_CSR_TOT  Total store conditional instructions                

PAPI_MEM_SCY  Cycles Stalled Waiting for memory accesses          
PAPI_MEM_RCY  Cycles Stalled Waiting for memory Reads             
PAPI_MEM_WCY  Cycles Stalled Waiting for memory writes            

PAPI_STL_ICY  Cycles with no instruction issue                    
PAPI_FUL_ICY  Cycles with maximum instruction issue               
PAPI_STL_CCY  Cycles with no instructions completed               
PAPI_FUL_CCY  Cycles with maximum instructions completed          

PAPI_BR_UCN   Unconditional branch instructions                   
PAPI_BR_CN    Conditional branch instructions                     
PAPI_BR_TKN   Conditional branch instructions taken               
PAPI_BR_NTK   Conditional branch instructions not taken           
PAPI_BR_MSP   Conditional branch instructions mispredicted        
PAPI_BR_PRC   Conditional branch instructions correctly
              predicted 

PAPI_FMA_INS  FMA instructions completed                          
PAPI_TOT_IIS  Instructions issued                                 
PAPI_TOT_INS  Instructions completed                              
PAPI_INT_INS  Integer instructions                                
PAPI_FP_INS   Floating point instructions                         
PAPI_LD_INS   Load instructions                                   
PAPI_SR_INS   Store instructions                                  
PAPI_BR_INS   Branch instructions                                 
PAPI_VEC_INS  Vector/SIMD instructions                            
PAPI_LST_INS  Load/store instructions completed                   
PAPI_SYC_INS  Synchronization instructions completed              
PAPI_FML_INS  Floating point multiply instructions                
PAPI_FAD_INS  Floating point add instructions                     
PAPI_FDV_INS  Floating point divide instructions                  
PAPI_FSQ_INS  Floating point square root instructions             
PAPI_FNV_INS  Floating point inverse instructions                 

PAPI_RES_STL  Cycles stalled on any resource    
PAPI_FP_STAL  Cycles the FP unit(s) are stalled 

PAPI_FP_OPS   Floating point operations         
PAPI_TOT_CYC  Total cycles                      
PAPI_HW_INT   Hardware interrupts
</PRE> 

<P>

<H1><A NAME="SECTION00720000000000000000"></A>
<A NAME="sec:cpc"></A>
<BR>
CPC
</H1>

<P>
Available counter names can be queried with the VampirTrace tool <TT>vtcpcavail</TT>.
In addition to the counter names, it shows how many performance counters can be
queried at a time. See below for a sample output.

<P>
<PRE>
% ./vtcpcavail
CPU performance counter interface: UltraSPARC T2
Number of concurrently readable performance counters
on the CPU: 2

Available events:
AES_busy_cycle
AES_op
Atomics
Br_completed
Br_taken
CPU_ifetch_to_PCX
CPU_ld_to_PCX
CPU_st_to_PCX
CRC_MPA_cksum
CRC_TCPIP_cksum
DC_miss
DES_3DES_busy_cycle
DES_3DES_op
DTLB_HWTW_miss_L2
DTLB_HWTW_ref_L2
DTLB_miss
IC_miss
ITLB_HWTW_miss_L2
ITLB_HWTW_ref_L2
ITLB_miss
Idle_strands
Instr_FGU_arithmetic
Instr_cnt
Instr_ld
Instr_other
Instr_st
Instr_sw
L2_dmiss_ld
L2_imiss
MA_busy_cycle
MA_op
MD5_SHA-1_SHA-256_busy_cycle
MD5_SHA-1_SHA-256_op
MMU_ld_to_PCX
RC4_busy_cycle
RC4_op
Stream_ld_to_PCX
Stream_st_to_PCX
TLB_miss

See the "UltraSPARC T2 User's Manual" for descriptions of these
events. Documentation for Sun processors can be found at:
http://www.sun.com/processors/manuals
</PRE>

<P>

<H1><A NAME="SECTION00730000000000000000"></A>
<A NAME="sec:necsx_pc"></A>
<BR>
NEC SX Hardware Performance Counter
</H1>
This is a list of all supported hardware performance counters for NEC SX machines.

<P>
<PRE>
SX_CTR_STM    System timer reg
SX_CTR_USRCC  User clock counter
SX_CTR_EX     Execution counter
SX_CTR_VX     Vector execution counter
SX_CTR_VE     Vector element counter
SX_CTR_VECC   Vector execution clock counter
SX_CTR_VAREC  Vector arithmetic execution clock counter
SX_CTR_VLDEC  Vector load execution clock counter
SX_CTR_FPEC   Floating point data execution counter
SX_CTR_BCCC   Bank conflict clock counter
SX_CTR_ICMCC  Instruction cache miss clock counter
SX_CTR_OCMCC  Operand cache miss clock counter
SX_CTR_IPHCC  Instruction pipeline hold clock counter
SX_CTR_MNCCC  Memory network conflict clock counter
SX_CTR_SRACC  Shared resource access clock counter
SX_CTR_BREC   Branch execution counter
SX_CTR_BPFC   Branch prediction failure counter
</PRE>

<P>

<H1><A NAME="SECTION00740000000000000000"></A>
<A NAME="sec:rusage_list"></A>
<BR>
Resource Usage
</H1>

<P>
The list of resource usage counters can also be found in the 
manual page of <TT>getrusage</TT>. Note that, depending on the operating
system, not all fields may be maintained. The fields supported
by the Linux 2.6 kernel are shown in the table.

<P>

<P>
<TABLE CELLPADDING=3>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Name</SPAN></TH>
<TH ALIGN="LEFT"><SPAN  CLASS="textbf">Unit</SPAN></TH>
<TH ALIGN="CENTER"><SPAN  CLASS="textbf">Linux</SPAN></TH>
<TH ALIGN="LEFT"><SPAN  CLASS="textbf">Description</SPAN></TH>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_utime</TT></TD>
<TD ALIGN="LEFT">ms</TD>
<TD ALIGN="CENTER">x</TD>
<TD ALIGN="LEFT">Total amount of user time used.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_stime</TT></TD>
<TD ALIGN="LEFT">ms</TD>
<TD ALIGN="CENTER">x</TD>
<TD ALIGN="LEFT">Total amount of system time used.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_maxrss</TT></TD>
<TD ALIGN="LEFT">kB</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Maximum resident set size.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_ixrss</TT></TD>
<TD ALIGN="LEFT">kB &#215; s</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Integral shared memory size (text segment) over the runtime.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_idrss</TT></TD>
<TD ALIGN="LEFT">kB &#215; s</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Integral data segment memory used over the runtime.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_isrss</TT></TD>
<TD ALIGN="LEFT">kB &#215; s</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Integral stack memory used over the runtime.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_minflt</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">x</TD>
<TD ALIGN="LEFT">Number of soft page faults (i.e. those serviced by reclaiming a page from the list of pages awaiting reallocation).</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_majflt</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">x</TD>
<TD ALIGN="LEFT">Number of hard page faults (i.e. those that required I/O).</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_nswap</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Number of times a process was swapped out of physical memory.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_inblock</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Number of input operations via the file system.  Note: This and <TT>ru_oublock</TT> do not include operations with the cache.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_oublock</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Number of output operations via the file system.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_msgsnd</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Number of IPC messages sent.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_msgrcv</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Number of IPC messages received.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_nsignals</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Number of signals delivered.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_nvcsw</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">x</TD>
<TD ALIGN="LEFT">Number of voluntary context switches, i.e. because the process gave up the processor before it had to (usually to wait for some resource to be available).</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_nivcsw</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">x</TD>
<TD ALIGN="LEFT">Number of involuntary context switches, i.e. a higher priority process became runnable or the current process used up its time slice.</TD>
</TR>
</TABLE>

<P>

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot1144">... (OTF)</A><A
 HREF="UserManual.html#tex2html3"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD><TT><A NAME="tex2html4"
  HREF="http://www.tu-dresden.de/zih/otf">http://www.tu-dresden.de/zih/otf</A></TT>

</DD>
<DT><A NAME="foot1145">... tool </A><A
 HREF="UserManual.html#tex2html5"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD><TT><A NAME="tex2html6"
  HREF="http://www.vampir.eu">http://www.vampir.eu</A></TT>

</DD>
<DT><A NAME="foot1146">...
Open MPI </A><A
 HREF="UserManual.html#tex2html7"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD><TT><A NAME="tex2html8"
  HREF="http://www.open-mpi.org/faq/?category=vampirtrace">http://www.open-mpi.org/faq/?category=vampirtrace</A></TT>

</DD>
<DT><A NAME="foot1170">... documentation </A><A
 HREF="UserManual.html#tex2html11"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD><TT><A NAME="tex2html12"
  HREF="http://www.cs.uoregon.edu/research/tau/docs/newguide/ch03s03.html#ManualSelectiveProfiling">http://www.cs.uoregon.edu/research/tau/docs/newguide/ch03s03.html#ManualSelectiveProfiling</A></TT>

</DD>
<DT><A NAME="foot1171">...
Dyninst </A><A
 HREF="UserManual.html#tex2html13"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD><TT><A NAME="tex2html14"
  HREF="http://www.dyninst.org">http://www.dyninst.org</A></TT>

</DD>
<DT><A NAME="foot1181">... CLAPACK</A><A
 HREF="UserManual.html#tex2html15"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD><TT><A NAME="tex2html16"
  HREF="www.netlib.org/clapack">www.netlib.org/clapack</A></TT> 

</DD>
</DL>
<BR><HR>

</BODY>
</HTML>
